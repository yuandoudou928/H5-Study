### 编程相关概念

#### 编程

让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程

#### 计算机语程序

就是计算机所执行的一系列的**指令集合**，而程序全部都是用我们所掌握的语言来编写的，所以人们如果要控制计算机，则需要通过计算机语言向计算机发出命令

#### 计算机语言

人与计算机之间通讯的语言。它是人与计算机之间传递信息的媒介，是用来控制计算机的一系列指令

计算机语言的种类非常的多，总的来说可以分成三大类：机器语言、汇编语言和高级语言

计算机最终所执行的都是机器语言，它是由“0”和“1”组成的二进制数，二进制是计算机语言的基础

#### 编程语言

通过类似于人类语言的 ”语言”来控制计算机，让计算机为我们做事情，这样的语言就叫做编程语言。不同的编程语言，有不同的语法，必须遵守

##### 编程语言的两种形式

- **汇编语言**：与机器语言实质是相同的，都是直接对硬件操作，只不过指令采用了英文缩写的标识符，容易识别和记忆
- **高级语言**：主要是相对于低级语言而言，它并不是特指某一种具体的语言，而是包括了很多编程语言，比如：C语言、C++、Java、C#、PHP、JavaScript、Python、Objective-C、Swift、Go语言等

##### 编程语言的分类

- 编译型语言

  定义：事先把所有的代码一次性翻译好，然后整体执行

  优点：运行更快

  不足：移植性不好，不跨平台

  编译型语言举例：c、c++

- 解释型语言

  定义：边翻译边执行（翻译一行，执行一行），不需要事先一次性翻译

  优点：移植性好，跨平台

  缺点：运行更慢

  解释型语言举例：JavaScript、php、Python

#### 翻译器

高级语言所编写的程序不能直接被计算机识别，必须经过转换才能被执行，为此，我们需要一个翻译器

翻译器可以将我们所编写的源代码转换（翻译）为机器语言，这也被称为二进制化

翻译器翻译的方式有两种

- **编译器**：在代码执行之前，事前把所有的代码一次性翻译好，生成中间代码文件，然后整体执行
- **解释器**：边翻译，边执行（在代码执行时进行及时翻译，并立即执行）。当编译器以解释的方式运行时，也称之为解释器

---

### JavaScript 简介

#### Web 前端有三层

- HTML：从语义的角度，描述页面结构

- CSS：从审美的角度，描述样式（美化页面）

- JavaScript：从交互的角度，描述行为（实现业务逻辑和页面控制）

#### JavaScript 的组成

- **ECMAScript**：JavaScript 的**语法标准**。包括变量、表达式、运算符、函数、if语句、for语句等。
- **DOM**：Document Object Model（文档对象模型），操作**页面上的元素**的API。比如让盒子移动、变色、改变大小、轮播图等等。
- **BOM**：Browser Object Model（浏览器对象模型），操作**浏览器部分功能**的API。通过BOM可以操作浏览器窗口，比如弹框、控制浏览器跳转、获取浏览器分辨率等等

通俗理解就是：ECMAScript 是 JS 的语法；DOM 和 BOM 浏览器运行环境为 JS提供的API

#### JavaScript 的特点

- 解释型语言

  JavaScript 是解释型语言，不需要事先被翻译为机器码；而是边翻译边执行（翻译一行，执行一行）

- 单线程

- ECMAScript 标准

  **ECMAScript不是一门语言，而是一个标准**。ECMAScript 规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准

#### JavaScript 的引入方式

- 行内式

  ```html
  <input type="button" value="点我" onclick="alert('点击了这个按钮')">
  ```

  - 可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），比如放在上面的  `onclick` 点击事件中
  - 这种书写方式，不推荐使用，原因是：可读性差，尤其是需要编写大量 JS代码时，容易出错；引号多层嵌套时，也容易出错
  - 关于代码中的「引号」，在HTML标签中，我们推荐使用双引号, JS 中我们推荐使用单引号

- 内嵌式

  ```html
  <body>
      <script type="text/javascript">
          alert("内嵌式引入");
      </script>
  </body>
  ```

  - text表示纯文本，因为 JavaScript 也是一个纯文本的语言
  - 可以将多行JS代码写到  `<script>`  标签中
  - 内嵌式 JS 是学习时常用的方式

- 引入外部的 JS 文件

  ```html
  <body>
    <script src="test.js"></script>
  </body>
  ```

  - 上面这段代码，依然是放到body标签里，可以和内嵌的js代码并列
  - 引用外部 JS文件的 `<script>` 标签中间不可以再写代码

---

### JavaScript 的语法

- JS 对换行、缩进、空格不敏感。每一条语句以分号结尾
- 所有符号，都是英语的。比如：括号、引号、分号
- 严格区分大小写

#### JavaScript 的注释

##### 单行注释

```javascript
// 我是单行注释
```

##### 多行注释

```javascript
/*
	我是多行注释
*/
```

#### JavaScript 的输入输出语句

##### 浏览器窗口中弹窗警告框

`alert("");`

##### 控制台输出

`console.log("");`

##### 弹出输入框

`promppt();`

用户输入的类型，获取到以后，都是字符串

#### 变量

##### 字面量

字面量 即 **常量**。是固定值，不可改变的

字面量有三种

- 数字

  数值的字面量非常简单，写上去就行，不需要任何的符号

  ```javascript
  alert(886);   // 123是数字，所以不需要加引号
  ```

- 字符串

  字符串的字面量也很简单，但一定要加上引号

  ```javascript
  console.log('我是字符串');
  ```

- 布尔字面量

  ```javascript
  if (true) {
  	console.log('如果为真，就走这里面的代码);
  }
  ```

##### 变量的概念

是用于存放数据的容器。我们通过「变量名」获取变量值，或者可以修改值等

变量的本质是，程序在内存中申请的一块用来存放数据的空间

##### 变量的声明和赋值

###### 变量的声明

- ES6 之前，同一使用 `var` 来声明一个变量
- ES6 及之后，增加了 `const`、`let` 关键字

同时声明多个变量，使用 `,` 隔开

```javascript
var name = "张三", age = 20;
```

###### 变量的赋值、变量值的修改

使用 `=` 号

###### 变量声明及赋值的几种特殊形式

- 先声明，再赋值（正常）

  ```javascript
  var a;
  a = 100;
  console.log(a);   // 100
  ```

- 不声明，只赋值（正常）

  ```javascript
  a = 100;
  console.log(a);   // 100
  ```

- 只声明，不赋值（打印：undefined）

  ```javascript
  var a;
  console.log(a);   // undefined
  ```

- 不声明，不赋值（报错）

  ```javascript
  console.log(a);
  ```

##### 变量名的命名规范

- 只能由字母(A-Z、a-z)、数字(0-9)、下划线(_)、美元符( $ )组成
- 不能以数字开头。也就是说，必须以字母(A-Z、a-z)、下划线(_)或者美元符( $ )开头。变量名中不允许出现空格
- 不能使用 JS 语言中保留的「关键字」和「保留字」作为变量名
- 建议用驼峰命名规则。比如：getElementById、matherAndFather、aaaOrBbbAndCcc
- 变量名会区分大小写（javascript 是区分大小写的语言）
- 变量名长度不能超过255个字符
- 汉语可以作为变量名。但是不建议使用，因为 low

##### 标识符、关键字、保留字

###### 标识符

由我们 **自主命名** 的，都可以称之为标识符

###### 关键字

由 JavaScript 自己已经使用了的单词

```
break、continue、case、default、

if、else、switch、for、in、do、while、

try、catch、finally、throw、

var、void、function、return、new、

this、typeof、instanceof、delete、with、

true、false、null、undefined
```

###### 保留字

预留的 关键字。现在还不是关键字，但是未来可能成为关键字

```
abstract、boolean、byte、char、class、const、

debugger、double、enum、export、extends、final、float、goto

implements、import、int、interface、long、native、package、

private、protected、public、short、static、super、synchronized、throws、

transient、volatile
```

##### 数据类型的作用

在计算机中，不同的数据所需占用的存储空间不同，为了充分利用存储空间，于是定义了不同的数据类型。而且，不同的数据类型，寓意也不同

JavaScript 是一种「弱类型语言」，或者说是一种「动态语言」，这意味着不需要提前声明变量的类型，在程序运行过程中，类型会自动被确定

JS 的变量数据类型，是在程序运行的过程中，根据等号右边的值来确定的。而且，变量的数据类型是可以变化的

```javascript
var name = '张三';

name = 123;   // 强制将变量 name 修改为 数字类型
```

#### JavaScript 中的数据类型

- **基本数据类型（值类型）**

  - String   字符串
  - Number   数字
  - Boolean   布尔型
  - Null   空对象
  - Undefined   未定义
  - Symbol 【ES6+】
  - BigInt【ES10+】

- **引用数据类型（引用型）**

  - Object   对象

    内置对象 Function、Array、Date、RegExp、Error等都是属于 Object 类型。也就是说，除了那五种基本数据类型之外，其他的，都称之为 Object 类型

##### 数据类型之间的区别

- 基本数据类型：参数赋值的时候，传值

- 引用数据类型：参数赋值的时候，传地址（修改的同一片内存空间）

```javascript
    <script>
        var a = 24;
        var b = a;

        a++;

        console.log(a);   // 打印结果：25
        console.log(b);   // 打印结果：24

        var obj1 = new Object();
        obj1.name = "123";

        var obj2 = obj1;

        obj1.name = "456"

        console.log(obj1.name);   // 打印结果：456
        console.log(obj2.name);   // 打印结果：456
    </script>
```

##### 堆内存和栈内存

###### 栈内存

主要用于存储基本数据类型的变量名及变量值，和引用数据类型的变量名和变量的引用（指针）

###### 堆内存

主要负责存储引用数据类型的变量值

![](https://images2018.cnblogs.com/blog/461976/201808/461976-20180823211511434-1707579794.png)

栈内存中的变量一般都是已知大小或者有范围上限的，算作一种简单的存储。而堆内存存储的是对象类型数据，对于大小这方面，一般都是未知的

##### String 字符串

字符串数据类型，可以是引号中的任意文本。其使用 `""` 或者 `''`

- 双引号与单引号不能混用

  ```javascript
  var a = 'hello";   // 报错：Uncaught SyntaxError: Invalid or unexpected token
  ```

- 同类引号不能嵌套：双引号里不能再放双引号，单引号里不能再放单引号

  3、单引号里可以嵌套双引号；双引号里可以嵌套单引号

###### 转义字符

在字符串中，我们可以使用 `\` 作为转义字符，用于在字符串中表示一些特殊符号

- `\"` 表示 `"`
- `\\` 表示 `\`
- `\r` 表示 回车
- `\n` 表示 换行（newline）
- `\t` 表示 缩进 （tab）
- `\b` 表示空格（blank）

###### 获取字符串的长度

`.length`

- 一个中文算一个字符，一个英文算一个字符
- 一个标点符号（包括中文标点、英文标点）算一个字符
- 一个空格算一个字符

###### 字符串的拼接

`+`

拼接后的新字符串 = 字符串 + 任意数据类型

```javascript
var str1 = '千古壹号' + '永不止步';
var str2 = '千古壹号' + 666;
var str3 = '千古壹号' + true;
var str4 = '千古壹号' + null;
var str5 = '千古壹号' + undefined;

var obj = { name: '千古壹号', age: 28 };
var str6 = '千古壹号' + obj;
```

###### 字符串的不可变性

字符串的值是不可以修改的。虽然看上去是修改了内容，但其实是地址变了，是在内存中新开辟了一个内存空间

###### 模版字符串

ES6 中新增的：最外边使用反引号（Tab 键上方），中间的值使用 `${变量}`

```javascript
var name = 'qianguyihao';
var age = '26';

console.log('我是' + name + ',age:' + age);   // 传统写法

console.log(`我是${name},age:${age}`);   // ES6 写法
```

##### Boolean 布尔型

布尔型只有两个值：`true` 和 `false`

主要用来做逻辑判断：true 表示真，false 表示假

布尔型和数字相加，true 为1，false 为 0

##### Number 数字型

在 JavaScript 中，所有的数字，都是 Number 类型。无论整数、浮点数（即小数）、无论大小、无论正负

###### 值的范围

- 最大值：`Number.MAX_VALUE` ，这个值为：1.7976931348623157e+308
- 最小值：`Number.MIN_VALUE` ，这个值为：5e-324

使用 Number 表示的变量超过了最大值，则返回 `Infinity`

- 无穷大（正无穷）：`Infinity`
- 无穷小（负无穷）：`-Infinity`

###### NaN

NaN 是一个特殊数字，表示 Not a Number，非数值

```javascript
console.log("abc" / 2);   // 打印结果：NaN
```

- Undefined 与任何数值计算的结果都为 NaN
- NaN 与任何值都不想等，包括 NaN 本身

###### `+`号

如果 `+` 两边都是 Number 类型，此时是数字相加。否则，就是连接符（用来连接字符串）

###### 隐式转换

`"2" + 1` 得到的结果是 `21` 这个字符串，但是 `"2" - 1` 的到的结果却是 `1` 这个数字。这是因为计算机自动帮我们进行了 **隐式转换**

计算机隐式转换的符号：`-`、`*`、`/`、`%`

###### 浮点数的运算

```javascript
var a = 0.1 + 0.2;
console.log(a);   // 打印结果：0.30000000000000004
```

打印结果是：0.30000000000000004，这是因为，计算机在做运算时，所有的运算都要转换成二进制去计算。然而，有些数字转换成二进制后，无法精确表示。比如说，0.1 转换成二进制后，是无穷的，因此存在浮点数计算不精确的问题

解决精度问题

- 简单的精度问题，可以使用 `toFixed()` 方法

- 要求较高的精度问题，使用开源库

  - Math.js

    属于很全面的运算库。但是文件大，压缩后都有500K。如果项目设计到大型的复杂运算，可以使用

  - decimal.js

    属于轻量级的运算库。压缩后只有32K

##### Null 空对象

null 专门用来定义一个 **空对象**

如果想定义一个变量用来保存引用型数据，但是还没有想好放什么内容，就可以初始化为 null

```javascript
let myObj = null;
console.log(typeof myObj);   // 打印结果：object
```

##### Undefined 未定义

###### 变量已声明，未赋值

```javascript
let name;

console.log(name);						// 打印结果：undefined
console.log(typeof name);			// 打印结果：undefined
```

###### 变量未声明，未赋值

```javascript
console.log(a);					// 未声明，直接使用。打印结果：Uncaught ReferenceError: a is not defined
console.log(typeof a);	// 未声明，检查类型。打印结果：undefined
```

###### 函数无返回值

一个函数，末尾没有 `return` 语句时，其实就是 `return undefined;`

```javascript
function play(){}

console.log(play());   // 打印结果：undefined
```

###### 调用函数时，未传参

```javascript
function play(name){
  console.log(name);   // 打印结果：undefined
}

play();
```

#### 数据类型转换

##### typeof 运算符

`typeof()` 用于 **获取变量的数据类型**，返回的值是小写的字符串

```
// 写法二：
var a = typeof 变量;

// 写法一：
var b = typeof(变量);
```

##### instanceof 运算符

用于判断一个实例是否属于某种类型

##### 数据类型转换的分类

- 显示类型转换

  - toString()

    - 该方法的转换，不会影响原变量，它会将转换结果返回

    - null 和 undefined 没有 toString() 方法。调用会报错

    - Number 类型调用 toString() 时，方法可以传一个参数，该参数的作用是指定转换时的进制，不传默认为 10 进制

      ```javascript
      var a = 255;
      a = a.toString(2);
      
      console.log(a);   				// 打印结果：11111111
      console.log(typeof(a));   // 打印结果：string
      ```

  - String()

    - 对于 Number 和 Boolean 而言，本质上就是调用 `toString()`
    - 对于 null 和 undefined ，则不会调用 `toString()`，它会将 null 直接转为 `null`，将 undefined 转为 "undefined"

  - Number()

    - 字符串 转 数字

      1. 如果字符串中是纯数字，则直接转换为数字（一个小数点是数字）
      2. 只要字符串中包含了非数字的内容，则转换为 NaN
      3. 如果一个字符串是空串，或者全是空格的字符串，则转换为 0

    - 布尔 转 数字

      1. true 转为 1
      2. false 转为 0

    - null 转 数字

      结果为：0

    - undefined 转 数字

      结果为：NaN

  - parseInt()

    - 字符串 转 数字

      1. 只保留字符串最开头的数字，后面的中文去掉（只去整数，小数点也会去掉）
      2. 如果字符串不是以数字开头，则转换为 NaN
      3. 如果字符串是空串或者全是空格的字符串，转换时会报错

    - Boolean 转 数字

      结果为：NaN

    - Null 转 数字

      结果为：NaN

    - Undefined 转 数字

      结果为：NaN

    说明：

    1. 对 **非String** 使用，会先转换为 **String**，再进行转换

    2. 自动带有截断小数的功能：**取整，不四舍五入**

       ```javascript
       var a = parseInt(5.8) + parseInt(4.7);
       console.log(a);   // 打印结果：9
       
       var b = parseInt(5.8 + 4.9);
       console.log(b);   // 打印结果：10
       ```

    3. 带两个参数时，第二个参数表示：第一个参数的进制时多少。返回的结果是：10进制

       ```javascript
       var c = "110";
       var d = parseInt(c, 16);   // 将 c 看作 16进制，然后进行转换
       console.log(d);   // 打印结果：272
       ```

  - parseFloat()

    - 字符串 转 浮点数

      保留字符串开头的数字，去掉后面的中文（数字可以去小数点）

  - Boolean()

    - 数字 转 布尔型

      除了 0 和 NaN，其余的都转换为 true

    - 字符串 转 布尔型

      除了空串，其余都为 true

    - null 和 undefined 都转为 true

    - 引用型数据类型，都转为 true

      空数组 `[]` 和空对象 `{}` ，转换的结果也是 true

    说明：

    1. 当非 Boolean 类型 与 Boolean 类型做比较时，会先把非 Boolean 类型转换为 Boolean 类型，再做比较

       ```javascript
       console.log(1 == true);   // 打印结果：true
       console.log(0 == true);   // 打印结果：false
       ```

    2. 使用 `!!` 可以显示转换为 Boolean 类型

       ```javascript
       console.log(!!3);   // 打印结果：true
       ```

- 隐式类型转换

  - isNaN ()

    判断指定的参数是否为NaN类型，返回的结果是 Boolean 类型

    **任何不能被转换为 Number 类型的参数，都会返回 true**

    执行过程：先调用 `Number()` 函数，然后将返回的结果和 NaN 比较

  - 自增/自减 运算符：++、--

    执行过程：先调用 `Number()` 函数，然后将返回的结果进行 `+1` 或者 `-1` 操作

  - 正号/负号：+a、-a

    这里的是正号/负号，不是加号/减号

    **运算的结果，会自动转换为 Number 类型**

    ```javascript
    var a = '666';
    var b = +a;
    
    console.log(typeof a); 		// 打印结果：string。说明 a 的数据类型保持不变。
    console.log(a); 					// 打印结果：666
    
    console.log(typeof b); 		// 打印结果：number。说明 b 的数据类型发生了变化。
    console.log(b); 					// 打印结果：666
    ```

  - 加号：+

    - 字符串 + 数字

      当加号两边，只要有一个是字符串，就会调用 `String()` 方法将数字转为字符串，然后再计算

    - Boolean + 数字

      true 按 `1` 来算，false 按 `0` 来算

    - null + 数字

      等价于：0 + 数字

    - undefined + 数字

      结果为：NaN

  - 运算符：-、*、/

    - 任何 非Number 类型做 `-`、`*`、`/` 运算时，都会先调用 `Number()` 函数进行转换，然后再进行计算
    - 任何值和字符串做加法运算，都会先转换为字符串，然后再做拼接操作
    - 任何值和 NaN 做 `-`、`*`、`/` 运算，返回结果都是 NaN

- 特殊的隐式类型转换

  - 逻辑运算符：&&、||、!

    非布尔值进行 **非、与、或** 运算时，会先将其转换为布尔值，然后再运算，但运算的结果是 **原值**

  - 关系运算符：<、>、<=、>=

    关系运算符得到的结果都是布尔值

#### 运算符

##### 运算符

运算符也叫操作符，是一种符号。通过运算符可以对一个或多个值进行运算，并获取运算结果

##### 表达式

由数字、运算符、变量组合而成的式子

表达式最终都会得到一个运算结果，这个结果称为表达式的**返回值**

##### 运算符的分类

- 算术运算符

  用于执行两个变量或值的算术运算

  ###### 常见的算术运算符

  +、-、*、/、%

  ###### 算术运算符的运算规则

  1. 先算乘、除、取余，后算加、减
  2. 有小括号，先算小括号

  ###### 浮点数运算的精度问题

  浮点数值的最高精度是 17 位小数，但在进行算术计算时，会丢失精度，导致计算不够准确

  ```javascript
  console.log(0.1 + 0.2);    // 运算结果不是 0.3，而是 0.30000000000000004
  
  console.log(0.07 * 100);   // 运算结果不是 7，而是 7.000000000000001
  ```

  因此，**不要直接判断两个浮点数是否相等**

- 自增/自减运算符

  - 自增/自减 的作用是使变量增加或减去 1

  - 自增/自减 分为 前置自增 `++a` 和后置自增 `a++` ，自减也是一样的

    - 需要注意 `a` 是变量，而 `a++` 或 `++a` 是表达式

    - 前置自增：先把变量的值 `+1`，再使用变量

    - 后置自增：先使用变量，再把变量的值 `+1`

      ```javascript
      var a = 5;
      var c = ++a;
      console.log(c);   // 打印结果：6
      
      var b = 5;
      var d = b++;
      console.log(d);		// 打印结果：5
      ```

- 一元运算符

  只操作一个数的运算符

  ###### 常见的一元运算符

  - typeof

  - 正号：`+`

    1. 不会对数字产生任何影响。比如：`2` 和 `+2` 是一样的

    2. 可以使用正号，将其它数据类型转换为 Number 类型

       ```javascript
       var aa = true;              // true 代表 1
       aa = +aa;                   // 这里是一元运算符
       console.log(aa);
       console.log(typeof aa);
       ```

  - 负号：`-`

    负号可以用于对数字进行取反

- 逻辑运算符

  - 逻辑 与（且）：` &&`

    **一假且假**

  - 逻辑 或：`||`

    **两真或真**

  - 逻辑 非： `!`

    对一个布尔值进行取反

  ###### 非布尔值的与、或运算

  非布尔进行与、或运算时，会先将其转为布尔值，然后再运算，但返回的结果是 **原值**

  ```javascript
  var result = 5 && 6;   // 运算过程：true && true;
  console.log('result：' + result);   // 打印结果：6（也就是说最后面的那个值。）
  ```

  ###### 非布尔值的非运算

  先转为布尔值，然后再运算，结果返回的是 **布尔值**

  ```javascript
  let a = 10;
  a = !a
  
  console.log(a);  // false
  console.log(typeof a); // boolean
  ```

- 赋值运算符

  将运算符右侧的值赋给运算符左侧的变量

- 比较运算符

  用于比较两个值之间的大小，如果关系成立返回 `true`，否则返回 `false`

  - 对于非数字、非字符串的比较，会先转换为数字，然后再比较
  - 对于两个字符串的比较，则比较多是 **Unicode编码**（是一位一位的进行比较）
  - 任何值和 NaN 比较，结果都是 `false`

  ###### `==`符负号

  **用于判断是否等于**，而不是赋值

  - 判断的时候会做 隐式转换，将不同数据类型，转为相同数据类型（通常情况下，转为数字）

    ```javascript
    console.log("6" == 6);			// 打印结果：true。这里的字符串"6"会先转换为数字6，然后再进行比较
    console.log(true == "1");   // 打印结果：true
    console.log(0 == -0);       // 打印结果：true
    console.log(null == 0);   	// 打印结果：false
    ```

  - `undefined` 衍生自 `null`，所以这两个值做相等判断时，会返回 `true`

  - NaN 不和任何值相等，包括他本身

  ###### `===` 符合

  全等符号，在比较时，**不会做类型的转换**

- 三元运算符（条件运算符）

  ```
  条件表达式 ？ 语句1 : 语句2;
  ```

  先对条件表达式求值，如果为 `true` 则执行语句1，否则执行语句2

  如果条件表达式的结果为一个非布尔值，则先转换为布尔值，再做运算

##### 运算符的优先级

- `.`、`[]`、`new`

- `()`
- `++`、`--`
- `!`、`~`、`+`（单目）、`-`（单目）、`typeof`、`void`、`delete`
- `%`、`*`、`/`
- `+`（双目）、`-`（双目）
- `<<`、`>>`、`>>>`
- 关系运算符：`<`、`<=`、`>`、`>=`
- `==`、`!==`、`===`、`!==`
- `&`
- `^`
- `|`
- `&&`
- `||`
- `?:`
- `=`、`+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`>>>=`、`&=`、`^=`、`|=`
- `,`

##### Unicode 编码

###### 字符串中使用 Unicode 编码

```
/u四位编码值    // 这里的编码值为 16进制
```

###### HTML 中使用 Unicode 编码

```
&#四位编码值;   // 这里的编码为 10进制
```

#### 流程控制语句

##### 代码块

用 `{}` 包围起来的代码，就是代码块

在 ES5 中，代码块，只具有 **分组** 的作用。代码块中的内容，在外部时完全可见的，如

```javascript
{
    var a = 2;
    alert('代码块');
    console.log('我是代码块');
}

console.log('a = ' + a);
```

##### 流程控制语句

在一程序执行的过程中，各条语句的执行顺序对程序的结果有直接影响

流程控制语句的分类

- 顺序结构

- 选择结构
  - if 语句
  - switch 语句
  
- 循环结构
  
  通过循环语句，可以反复的执行一段代码多次
  
  - while 语句
  - for 语句
  - do...while 语句

##### 顺序结构

按照代码的先后顺序，依次执行

```
开始  —>  语句1  ->  语句2  ->  语句3  ->  结束
```

##### if 语句

- 条件判断语句

  条件成立，才执行。如果条件不成立，则跳过

  ```
  if(条件表达式){
  	// 条件成立，执行的代码
  }
  ```

- 条件分支语句

  - 格式一

    ```
    if(条件表达式){
    	// 条件成立，执行的代码
    } else {
    	// 条件不成立，执行的代码
    }
    ```

  - 格式二：多分支 if 语句

    ```
    if(条件表达式1){
    	// 条件表达式1成立，执行的代码
    } else if (条件表达式2){
    	// 条件表达式1不成立，条件表达式2成立，执行的代码
    } else if (条件表达式3){
    	// 条件表达式1、2都不成立，条件表达式3成立，执行的代码
    } else {
    	// 上面的所有条件都不成立，执行的代码
    }
    ```

##### switch 语句（条件分支语句）

```
switch(表达式/值){
	case 值1:
		语句体1;
		break;
	case 值2:
		语句体2;
		break;
	...
	default:
		语句体 n+1;
		break;
}
```

1. switch 后面括号里，可以是表达式，也可以是值，通常是一个变量
2. case 后面的值可以是任意数据类型，也可以是表达式
3. 如果有 case 的 `break;` 没有写，那么执行该 case 的语句体后，会执行后面 case 的语句体，直到遇到 `break;` 语句

###### switch 语句执行流程

![](https://camo.githubusercontent.com/b42a457584835ae032ea18af433cb356ae64890b/687474703a2f2f696d672e736d79687661652e636f6d2f32303139303831355f313530312e706e67)

1. 计算表达式的值，然后依次与 case 的值进行比较，一旦有相等的值，则执行该 case 的语句体，直到执行该 case 里面的 `break;` 语句，那么该 switch 语句执行完成
2. 如果表达式的值与所有 case 的值都不相等，那么就执行 `default` 里面的语句体

##### for 循环语句

```
for(初始表达式①; 条件表达式②; 更新表达式④){
	// 条件表达式成立，执行的代码
}
```

1. 初始表达式①，初始化变量（初始表达式只执行一次）
2. 条件表达式②，判断是否执行代码③。条件表达式②为 `true` ，执行代码③，否则终止循环
3. 代码③执行完成后，更新表达式④，然后执行条件表达式②

###### for...of

- `for...of` 的循环可以避免我们开拓内存空间，增加代码运行效率

- 建议用来遍历数组，获取的是数组的元素
- 不能用于遍历对象

###### for...in

- 遍历数组时，获取的是 index
- 遍历对象时，获取的是 属性名

##### while 循环语句

```
while(条件表达式/值){
	// 条件表达式成立，执行的代码
}
```

1. 判断条件表达式，成立，则执行代码，否则，终止循环
2. 可以使用 `break;` 来终止循环
3. 条件表达式，通常是一个变量，可以在 代码中，修改变量的值

##### do...while 循环语句

```
do {
	// 代码
} while(条件表达式)
```

1. 先执行代码，再执行条件表达式
2. 能保证代码至少执行一次

##### 循环语句的终止

###### break

退出**整个**循环语句

###### continue

跳过**当前**循环

###### label 标签

退出**指定**的循环

注意：

1. if 语句不能使用 break、continue，会报错
2. break、continue 默认对离它最近的循环起作用
3. break、continue 都可以使用 label

#### 对象

##### 开发语言的分类

- 面向过程

  先分析好具体的步骤，然后按照步骤，一步步解决问题

  *更加关心的是干活的过程，谁去干活，不关心*

  优点：性能比面向对象高，适合跟硬件联系很紧密的东西

  缺点：没有面向对象易维护、易复用、易扩展

- 面向对象

  以对象来划分问题，而不是步骤

  *重点是对象，更加关心的是干活的人*

  优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，使系统更佳灵活、更加易于维护
  
  缺点：性能比面向过程低

JavaScript 是面向对象的语言。在 JavaScript 中，对象是一组无序的，相关属性和方法的集合

对象的作用：封装信息

对象具有 **特征（属性）** 和 **行为（方法）**

对象的属性值，可以是**任意数据类型**，也可以是**函数**，或者**对象**

只要不是 String、Number、Boolean、Null、Undefined 这五个，就全部都是对象

*如果两个变量，保存的是通一个对象的引用，当通过一个变量修改属性值时，另一个也会受影响*

JavaScript 中的面向对象，是基于 **原型** 的面向对象（基于原型的面向对象：JavaScript 中的对象（Object）是依靠构造器（constructor）和原型（prototype）构造出来的）

##### 面向对象的编程思想

对代码和数据进行封装，并以对象调用的方式，对外提供统一的调用接口

##### 引用类型 的传值

引用类型的数据，赋值相当于拷贝地址，即栈内存中，引用是相同的。如果想在堆内存中有单独的空间，可以使用 `Object.assign()`

```javascript
var obj1 = {name: "我是对象"};
var boj2 = Object.assign({}, obj1);
```

##### 面向对象的特征

- 封装
- 继承
- 多态

###### 继承的几种方式

- 通过构造函数继承

  在子类构造函数中通过 `call()` 调用父类的构造函数

- 原型链继承

  子类型的原型为父类型的一个实例对象

- 组合继承

##### 对象的分类

- 内置对象

  由 ES 标准中定义的对象，在任何 ES 的实现中都可以使用

  如：Arguments、Object、Math、Date、String、Array、Number、Boolean、Function、Error、RegExp等

- 宿主对象

  由 JS 等运行环境提供的对象。目前来讲，主要指由浏览器提供的对象

  如：BOM、DOM、console、document

- 自定义对象

  由开发人员自己定义的对象

##### 基本包装类型

属性和方法只能添加给对象，不能添加给基本数据类型。即，基本数据类型，不能添加属性和方法

- 基本数据类型

  基本数据类型，无法绑定属性和方法

  ```javascript
  var str = "abc";
  str.text = "123";
  
  console.log(typeof str);   // 打印结果：string
  console.log(str.text);		 // 打印结果：undefined
  ```

- 引用数据类型

  引用数据类型，可以绑定属性和方法

  ```javascript
  var strObj = new String("abc");
  strOjb.text = "123";
  
  console.log(strObj);
  console.log(typeof strObj);
  console.log(strObj.text);
  ```

###### JavaScript 为我们提供的基本包装类型

- String()：将基本数据类型字符串，转换为 String 对象
- Number()：将基本数据类型数字，转为 Number 对象
- Boolean()：将基本数据类型布尔型，转为 Boolean 对象

通过包装类，可以将基本数据类型的数据转为对象。但在实际开发中，尽量不要使用，因为可以带来不可预期的结果

```javascript
var boo1 = new Boolean(true);
var boo2 = new Boolean(true);

console.log(boo1 === boo2);   // 打印结果竟然是：false
```

```javascript
var boo3 = new Boolean(false);

if (boo3) {
    console.log('qianguyihao'); // 这行代码竟然执行了
}
```

###### 基本包装类的作用

当我们对一些基本数据类型的值去调用属性和方法时，浏览器会**临时使用包装类将基本数据类型转换为引用数据类型**，这样的话，基本数据类型就有了属性和方法，然后再调用对象的属性和方法；调用完以后，再将其转换为基本数据类型

###### 在底层，字符串以字符数组的形式保存

```javascript
var str = 'smyhvae';
console.log(str.length);   // 获取字符串的长度
console.log(str[2]); 			 // 获取字符串中的第2个字符
```

上方代码中，`smyhvae`这个字符串在底层是以`["s", "m", "y", "h", "v", "a", "e"]`的形式保存的。因此，我们既可以获取字符串的长度，也可以获取指定索引 index 位置的单个字符

再比如，String 对象的很多内置方法，也可以直接给字符串用。此时，也是临时将字符串转换为 String 对象，然后再调用内置方法

##### 内置对象 String

**字符串的所有方法，都不会改变原字符串**（字符串的不可变性），操作完后，会返回一个新的值

- `indexOf()/lastIndexOf()`   获取字符串中指定内容的索引

  ```
  索引值 = str.indexOf(想要查询的字符串, [起始位置]);
  ```

- `search()`   获取字符串中指定内容的索引

  ```
  索引值 = str.search(想要查找的字符串);
  
  索引值 = str.search(正则表达式);
  ```

- `includes()`   判断字符串中是否包含指定的内容

  ```
  布尔值 = str.includes(想要查找的字符串, [起始位置]);
  ```

- `startsWith()`   判断字符串是否以指定的内容开头

  ```
  布尔值 = str.startsWith(想要查找的内容, [起始位置]);
  ```

- `endsWith()`   判断字符串是否以指定的内容结尾

  ```
  布尔值 = str.endsWith(想要查找的内容, [结束位置]);
  ```

- `charAt(index)`   获取指定位置的字符

  ```
  字符 = str.charAt(index);
  ```

- `str[index]`   获取指定位置的字符

  H5 标准里新增的特性

  ```
  字符 = str[index];
  ```

- `charCodeAt(index)`   获取字符串指定位置的字符的 Unicode 编码

  ```
  字符 = str.charCodeAt(index);
  ```

  可以用来判断用户按了哪个按键

- `slice()`   从字符串中截取指定范围的内容

  ```
  新字符串 = str.slice(开始索引, 结束索引);   //两个参数都是索引值。包左不包右
  ```

  - `str.slice(-3)` 表示从倒数第三个开始，截取到最后
  - `str.slice(1, -1)` 表示从第一个截取到倒数第一个

- `substring()`   从字符串中截取指定范围的内容

  ```
  新字符串 = str.substring(开始索引, 结束索引); //两个参数都是索引值。包左不包右
  ```

  与 `slice()` 的区别

  - `substring()`不能接受负值作为参数。如果传递了一个**负值**，则默认使用 0
  - `substring()`还会自动调整参数的位置，如果第二个参数小于第一个，则自动交换位置

- `substr()`   从字符串中截取指定长度的内容

  ```
  字符串 = str.substr(开始索引, 截取的长度);
  ```

- `String.fromCharCode()`   根据 Unicode 编码获取字符

  ```
  字符 = String.fromCharCode(Unnicode编码);
  ```

- `concat()`   连接两个字符串

  ```
  新字符串 = str1.concat(str2);
  ```

- `split()`   将字符串转换为数组

  ```
  新数组 = str.split([分隔符]);
  
  新数组 = str.split([正则表达式]);
  ```

- `replace()`   替换字符串中指定的内容

  **默认只会替换匹配到的第一个内容**

  ```
  新的字符串 = str.replace(被替换的字符，替换的字符);
  
  新的字符串 = str.replace("正则表达式"，替换的字符);
  ```

- `repeat()`   将字符串重复指定的次数

  ```
  新字符串 = str.repeat(重复的次数);
  ```

- `match()`   从一个字符串中，提取符合条件的内容

  ```
  新内容 = str.match("正则表达式");
  ```

- `trim()`   去掉字符串前、后的空白

- `toLowerCase()`   将字符串中的大写转为小写

- `toUpperCase()`   将字符串中的小写转为大写

- html 方法

  - anchor()
  - big()
  - sub()
  - sup()
  - link()
  - bold()

##### 内置对象 Number

- `Number.isInteger()`   判断是否为整数

  ```
  布尔值 = Number.isInteger(数字);
  ```

- `toFixed()`   指定小数点后保留的位数（四舍五入）

  ```
  字符串 = myNum.toFixed(num);
  ```

##### 内置对象 Math

Math 属于一个工具类，它的使用不需要通过 new 来创建对象，而是直接使用它的属性和方法

| 方法              | 描述                                       | 备注               |
| ----------------- | ------------------------------------------ | ------------------ |
| Math.PI           | 圆周率                                     | Math对象的属性     |
| Math.abs()        | 返回绝对值                                 | 参数可以接收字符串 |
| Math.random()     | 生成0-1之间的**随机浮点数**                | 取值范围是 [0，1)  |
| Math.floor()      | **向下取整**（往小取值）                   |                    |
| Math.ceil()       | **向上取整**（往大取值）                   |                    |
| Math.round()      | 四舍五入取整（正数四舍五入，负数五舍六入） |                    |
| Math.max(x, y, z) | 返回多个数中的最大值                       |                    |
| Math.min(x, y, z) | 返回多个数中的最小值                       |                    |
| Math.pow(x,y)     | 乘方：返回 x 的 y 次幂                     |                    |
| Math.sqrt()       | 开方：对一个数进行开方运算                 |                    |

###### 生成 [0, x] 之间的随机数

```
 Math.round(Math.random() * x);
```

###### 生成 [x, y] 之间的随机数

```
 Math.round(Math.random() * (y - x) + x);
```

###### 生成 [x, y] 之间的随机整数

```
Math.floor(Math.random() * (y - x + 1)) + x;
```

##### URI 的编码和解码

- `encodeURIComponent(str)`   把字符串作为 URI 组件进行编码
- `decodeURIComponent(str)`   把字符串作为 URI 组件进行解码

##### 内置对象 Date

| 方法名            | 含义           | 备注                 |
| ----------------- | -------------- | -------------------- |
| getFullYear()     | 获取年份       |                      |
| getMonth()        | 获取月： 0-11  | 0代表一月            |
| getDate()         | 获取日：1-31   | 获取的是几号         |
| getDay()          | 获取星期：0-6  | 0代表周日，1代表周一 |
| getHours()        | 获取小时：0-23 |                      |
| getMinutes()      | 获取分钟：0-59 |                      |
| getSeconds()      | 获取秒：0-59   |                      |
| getMilliseconds() | 获取毫秒       | 1s = 1000ms          |

###### 创建 Date 对象

- 无参构造方法

  不传递参数时，表示的是获取系统的当前时间对象。即：获取当前代码执行的时间

- 有参构造方法

  传递参数时，表示获取指定时间的时间对象。参数可以是：字符串、时间数字、时间戳

  传时间数字时，月份从 0 开始

###### 获取 Date 对象的时间戳

时间戳：指的是从格林威治标准时间的`1970年1月1日，0时0分0秒`到当前日期所花费的**毫秒数**（1秒 = 1000毫秒）

```javascript
// 方式一：（最常用的写法）
const timestamp1 = +new Date();
console.log(timestamp1);

// 方式二：（较常用的写法）
const timestamp2 = new Date().getTime();
console.log(timestamp2);

// 方式三：
const timestamp3 = new Date().valueOf();
console.log(timestamp3);

// 方式4：
const timestamp4 = new Date() * 1;
console.log(timestamp4);

// 方式5：
const timestamp5 = Number(new Date());
console.log(timestamp5);
```

###### 获取当前时间的时间戳

H5 标准中的新增特性

```
Date.now();
```

###### 格式化时间对象

```
new Date().format("yyyy-MM-dd");
```

###### Moment.js [中文官网](http://momentjs.cn/)

Moment.js 是一个轻量级的 JavaScript 时间库，我们可以利用它很方便地进行时间操作，提升开发效率

##### 内置对象 Array

数组使用数字作为 **索引** 来操作元素，索引从 0 开始

数组中的元素可以是任意数据，也可以是对象，也可以是函数，也可以是数组。如果数组中的元素是数组，这该数组是多维数组

###### 创建数组对象

- 方式一：使用字面量创建数组

  ```javascript
  var arr1 = [];   				// 创建一个空数组
  
  var arr2 = [1, 2, 3];   // 创建带初始值的数组
  ```

- 方式二：使用构造函数创建数组

  ```
  let arr1 = new Array(参数);
  
  let arr2 = Array(参数);
  ```

  - 如果参数为空，表示创建一个空数组
  - 如果参数为一个数值，表示创建数组的长度
  - 如果有多个参数，表示数组中的元素

###### 向数组中添加元素

```
数组[索引] = 值;
```

###### 获取数组中的元素

```
值 = 数组[索引];
```

如果索引大于数组的长度，系统不会报错，而是返回 `undefined`

###### 获取数组的长度

```
数组的长度 = 数组.length;
```

对于连续的数组，使用 length 可以获取到数组的长度(元素的个数)；对于非连续的数组，使用 length 会获取到数组的最大的索引+1。因此，尽量不要创建非连续的数组

###### 修改数组的长度

```
数组.length = 数组的新长度;
```

- 如果修改的 length 大于原长度，则多出部分会空出来，置为 null
- 如果修改的 length 小于原长度，则多出的元素会被删除，数组将从后面删除元素
- 特例：伪数组 arguments 的长度可以修改，但是不能修改里面的元素

###### 数组的方法

- `Array.isArray()`   判断是否为数组

  ```
  布尔值 = Array.isArray(被检查的数组);
  ```

- `toString()`   数组转换为字符串

  ```
  字符串 = 数组.toString();   // 使用 , 分隔每个元素
  ```

  其它方法

  ```
  字符串 = String(数组);
  
  字符串 = 数组.join(",");   // 将数组转换为字符串，每一个元素用 , 分隔
  ```

- `Array.from()`   将伪数组或可遍历对象转换为真数组

  ES6 新增

  **伪数组：**包含 `length` 属性的对象或可迭代的对象。伪数组的原型链中没有 Array.prototype，而真数组的原型链中有 Array.prototype。因此伪数组没有数组的一般方法，比如 pop()、join() 等方法

  ```
  真数组 = Array.from(伪数组);
  ```

  其它方法（ES6之前）

  ```
  真数组 = Array.prototye.slice.call(伪数组);
  
  真数组 = [].slice.call(伪数组);
  ```

- `Array.of()`   创建数组

  ```
  数组 = Array.of(元素1, 元素2, 元素3, ...);
  ```

  与 `new Array()` 的区别：当参数只有一个时，`Array.of()` 表示数组的元素

- `push()`   向数组末尾插入一个或多个元素，并返回新数组的长度

  ```
  新数组长度 = 数组.push(元素);
  ```

- `pop()`   删除数组最后一个元素，并返回被删除的元素

  ```
  被删除的元素 = 数组.pop();
  ```

- `unshift()`   在数组最前面插入一个或多个元素，并返回新数组的长度

  ```
  新数组的长度 = 数组.unshift(元素);
  ```

- `shift()`   删除数组中的第一个元素，并返回被删除的元素

  ```
  被删除的元素 = 数组.shift();
  ```

- `slice()`   从数组中获取指定范围的元素，并返回新数组

  ```
  新数组 = 数组.slice(开始位置索引, 结束位置索引);
  ```

  - 包含开始位置，不包含结束位置
  - 不加参数，则获取所有的元素
  - `slice(2)`   从第二个值开始获取，直到末尾
  - `slice(-2)`   获取最后两个元素
  - `slice(4, 2)`   空

- `splice()`   删除数组中指定范围的元素，并返回被删除元素组成的新数组

  ```
  新数组 = 数组.splice(开始位置索引, [需要删除的个数], [新元素1, 新元素2, 新元素3, ...]);
  ```

  - 新元素，为删除指定元素后，向原数组末尾插入的新元素
  - `splice(0)`   删除数组中的所有元素
  - `splice(2)`   删除第2个及其后面的所有元素
  - `splice(-2)`   删除最后两个元素

- `fill()`   用一个固定值填充数组，并返回新数组

  ```
  新数组 = 数组.fill(固定值, [开始位置], [结束位置]);
  ```

  - 包含开始位置，不包含结束位置

- `concat()`   合并多个数组，并返回新数组

  ```
  新数组 = 数组1.concat(数组2, 数组3, ...);
  ```

  其它方法

  ```
  新数组 = [元素1, 元素2, ..., 元素n, ...数组]
  ```

- `join()`   将数组转为字符串，并返回转换后的字符串

  ```
  字符串 = 数组.join([分隔符]);
  ```

  - 分隔符默认为 `,`

- `reverse()`   反转数组，并返回反转后的数组

  会改变原数组

  ```
  反转后的数组 = 数组.reverse();
  ```

- `sort()`   将数组元素进行从小到大排序，并返回排序后的数组

  会改变原数组

  ```
  排序后的数组 = 数组.sort([排序规则]);
  ```

  - 默认排序规则为 `Unicode`

  - 排序规则，可以是一个回调函数，函数的返回值

    - 如果返回一个大于 0 的值，则元素会交换位置
    - 如果返回一个小于 0 的值，则元素位置不变
    - 如果返回一个等于 0 的值，则认为两个元素相等，则不交换位置

    ```
    排序后的数组 = 数组.sort(function (a, b) {
        return a - b; // 升序排列
        // return b - a; // 降序排列
    });
    
    简化（升序）：
    let 排序后的数组 = 数组.sort((a, b) => a - b);
    ```

- `indexOf()`   从前往后，检查数组中是否包含指定元素，并返回第一次出现的索引值

  ```
  索引值 = 数组.indexOf(待查找的元素, [起始位置]);
  ```

  - 在检查时，是严格类型约束，即 `===`

- `lastIndexOf()`   从后往前，检查数组中是否包含指定元素，并返回第一次出现的索引值

- `find()`   找出第一个满足指定条件的元素，并返回该元素

  ```
  满足指定条件的元素 = 数组.find((item, index) => {
  	return 条件;
  });
  ```

- `findIndex()`   找出第一个满足指定条件的元素，并返回该元素的索引

  ```
  满足指定条件的元素的索引 = 数组.find((item, index) => {
  	return 条件;
  });
  ```

- `every()`   判断数组中的所有元素，是否都满足指定条件

  ```
  布尔值 = 数组.every(function(item, index, arr){
  	if(条件){
  		return false;
  	}
  	return true;
  });
  ```

  - 返回值只能是 布尔值
  - 所有元素都满足条件，返回 true，否则返回 false
  - arr 指的是当前数组

- `some()`   判断数组中，是否有一个元素，满足指定条件

  - 只要有一个元素满足指定条件，就返回 true，然后停止遍历
  - 所有元素都不满足条件，返回 false

- `valueOf()`   返回数组本身

- 遍历数组

  ```
  数组/boolean/无 = 数组.every/filter/forEach/map/some(
                          function(item, index, arr){
                                          程序和返回值；
  ```

  - `for`   循环遍历

    ```
    for(let i = 0; i < 数组.length; i++){
    	数组的元素 = 数组[i];
    }
    ```

  - `forEach()`   遍历数组

    只支持 IE8 以上版本。且没有返回值

    ```
    数组.forEach((item, index, arr) => {
    	
    });
    ```

    - 可以通过 index、arr 来修改原数组

  - `map()`   加工原数组中的每个元素，并将加工后的元素组成新数组返回

    不会改变原数组

    ```
    新数组 = 数组.map(function(item, [index], [arr]){
    		return newItem;
    })
    ```

  - `filter()`   将满足条件的数组，组成新数组返回

    不会改变原数组

    ```
    新数组 = 数组.filter((item) => {
    	if(条件){
    		return true;
    	}
    	return false;
    });
    ```

  - `reduce()`   累加器。接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值

    ```
    处理结果 = 数组.reduce(function (previousValue, currentValue, currentIndex, [arr]) {
    	return 处理元素;
    }, [initialValue]);
    ```

    - previousValue：必填，上一次调用回调函数时的返回值
    - currentValue：必填，当前正在处理的数组元素
    - currentIndex：选填，当前正在处理的数组元素下标
    - arr：选填，调用 reduce()方法的数组
    - initialValue：选填，可选的初始值（作为第一次调用回调函数时传给 previousValue 的值）

    参考：https://juejin.im/post/6844903940144775176

##### 自定义对象

###### 创建对象的方法

- 通过 Object

  ```
  var 对象名 = new Object();
  ```

- 对象字面量

  对象字面就是一个 `{}` ，里面的属性和方法均是 **键值对**

  - 键：相当于属性名。键可以不使用双引号
  - 值：相当于属性值。可以是任意类型，且必须使用双引号引起来

  ```
  var 对象名 = {
  	属性名: 属性值;
  }
  ```

  与 JSON 的区别：JSON 的属性必须用双引号引号引起来，对象字面量可以省略

  对象和 json 没有长度，json.length 的打印结果是 undefined。于是乎，自然也就不能用 for 循环遍历（因为遍历时需要获取长度 length）

  JSON 采用 `for...in...`进行遍历

- 工厂模式

  ```javascript
  function createObj(name, age){
  	var obj = new Object();
  	obj.name = name;
  	obj.age = age;
  	return obj;
  }
  
  var obj1 = createObj("张三", 12);
  var obj2 = createObj("李四", 20);
  ```

- 利用构造函数

  ```javascript
  function Student(name){
  	this.name = name;
  }
  
  var stu1 = new Student("张三");
  var stu2 = new Student("李四");
  ```

##### 对象的基本操作

- 向对象中添加属性

  ```
  对象名.属性名 = 属性值;
  ```

- 获取对象的属性

  ```
  方法1:
  属性值 = 对象名.属性名;
  
  方法2:
  属性值 = 对象名["属性名"];
  ```

- 修改对象的属性值

  ```
  对象名.属性名 = 新的属性值;
  ```

- 删除对象的属性

  ```
  delete 对象名.属性名;
  ```

- 检查一个对象是否包含指定的属性

  ```
  "属性名" in 对象名;
  ```

- 遍历对象

  ```
  for(const 属性名 in 对象名){
  	
  }
  ```

- 返回对象的所有键值组成的数组【ES5+】

  ```
  var arr = Object.keys(对象名);
  ```

- 对象的拷贝

  - 浅拷贝

    只拷贝最外面一层数据。更深层次的对象，只拷贝引用

    - 使用 `for...in` 实现浅拷贝

      ```javascript
      const obj1 = {
          name: "张三",
          age: 28,
          info: {
              desc: "很厉害"
          }
      };
      
      const obj2 = {};
      for (let key in obj1) {
          obj2[key] = obj1[key];
      }
      
      console.log('obj2:' + JSON.stringify(obj2));
      
      obj1.info.desc = '永不止步'; // 当修改 obj1 的第二层数据时，obj2的值也会被改变。所以  for in 是浅拷贝
      
      console.log('obj2:' + JSON.stringify(obj2));
      ```

    - 使用 `Object.assign()` 实现浅拷贝（推荐）

      如果属性名相同，则值会被覆盖

      ```javascript
      const obj1 = {
          name: "张三",
          age: 28,
          info: {
              desc: "很厉害"
          }
      };
      
      // 写法1
      const obj2 = Object.assign({}, obj1);
      
      
      // 写法2
      const obj3 = {};
      Object.assign(obj3, obj1);
      
      // 写法3
      const obj4 = {};
      const obj5 = Object.assign(obj4, obj1);
      ```

  - 深拷贝

    每一层级别的数据都会拷贝，即把对象的所有数据复制到新的内存空间中

    - 使用 `for...in` 递归实现深拷贝

      ```javascript
      function deepCopy(newObj, oldObj) {
        for (const key in oldObj) {
          let item = oldObj[key];
          if (item instanceof Array) {
            newObj[key] = [];
            deepCopy(newObj[key], item);
          } else if (item instanceof Object) {
            newObj[key] = {};
            deepCopy(newObj[key], item);
          } else {
          	newObj[key] = item;
          }
        }
      }
      ```
      
      ```javascript
      function deepClone(obj, hash = new WeakMap()) {
        // 如果是 null 或者 undefined ，就不进行拷贝
        if (obj === null) {
      		return obj;
        }
        if (obj instanceof Date) {
      		return new Date(obj);
        }
        if (obj instanceof RegExp) {
      		return new RegExp(obj);
        }
        if (typeof obj !== "object") {
      		return obj;
        }
        if (hash.get(obj)) {
      		return hash.get(obj);
        }
        let tempObj = new obj.constructor();
        hash.set(obj, tempObj);
        for (let key in obj) {
      		if (obj.hasOwnProperty(key)) {
        		tempObj[key] = deepClone(obj[key], hash);
      		}
        }
        return tempObj;
      }
      ```

- 冻结对象

  一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改

  ```
  对象名 = Object.freeze(对象名);
  ```

#### 函数

##### 函数的介绍

函数，是将一些功能或语句进行封装，在需要的时候，通过调用的形式，执行这些语句

**函数也是一个对象**

使用 `typeof` 检查一个函数对象时，会返回 `function`

###### 函数的作用

- 将大量重复的语句抽取出来，写在函数里面，以后需要这些语句的时候，可以直接调用函数，避免重复劳动
- 简化编程，让编程模块化。高内聚，低耦合

##### 函数的定义/声明

###### 使用关键字 `function` 来创建一个函数

- 命名函数

```
function 函数名([形参1, 形参2, ...]){
	// 语句...
}
```

- 匿名函数

  匿名函数，即没有函数名的函数

```
var 变量名 = function([形参1, 形参2, ...]){
	// 语句...
}
```

###### 使用 `Function` 对象来创建函数

```
var 函数名 = new Function("形参1", "形参2", ..., "函数体");
```

- `Function` 的形参和函数体必须是**字符串**

##### 函数的调用

- 普通函数的调用

  ```
  函数名();
  // 相当于
  window.函数名();
  
  
  函数名.call();
  ```

- 通过对象来调用

  ```javascript
  var obj = {
  	str: "我是一个字符串",
  	fun1: function(){
  		console.log("我是一个方法");
  	}
  }
  
  obj.fun1();
  ```

  如果一个函数作为一个对象的属性，那么，这个函数就是这个对象的**方法**

- 立即执行函数

  ```
  (function(){
  	// 语句...
  })();
  ```

  - 立即执行函数在定义完后，会被立即调用
  - 立即执行函数，只会被执行一次，因为没有函数名，无法调用

- 通过构造函数来调用

  ```
  function 函数名(){
  	// 语句
  }
  
  new 函数名();
  ```

- 绑定事件函数

  ```javascript
  <body>
      <div id="btn1">按钮1</div>
  
      <script>
          var btn = document.getElementById("btn1");
          btn.onclick = function(){
              console.log("绑定事件函数");
          };
      </script>
  </body>
  ```

- 定时器函数

  ```javascript
  // 每隔一秒，数字加1
  var num = 0;
  setInterval(function(){
    num++;
  }, 1000);
  ```

##### 函数的形参和实参

###### 形参

- 形式上的参数。定义函数时，传递的参数。形参不知道具体的值
- 形参，在定义函数时，写在 `()` ，多个形参，使用 `,` 隔开
- 形参的默认值为 `undefined`

###### 实参

- 实际的参数。在调用函数时，传递的参数。实际参数是具体的值
- 在调用函数时，写在 `()` 里的参数，多个实参，使用 `,` 隔开
- 实参可以是任意类型，调用函数时，解析器不会检查实际参数的类型
- 如果实参数量多于形参，多余的实参不会被赋值
- 如果实参数量少于形参，多余的形参倍定义为 `undefined`

##### 函数的返回值

函数的返回值使用 `return` 来返回

- `return` 的作用时终止当前函数，`return` 后的所有代码都不会执行
- `return` 的值将作为函数的执行结果返回
- `return` 后不跟任何值，相当于返回 `undefined` 
- 如果函数中不写 `return` ，也会默认返回 `undefined`
- `return` 可以返回任意数据类型，可以是对象，或者函数
- `return` 只能返回一个值。如果用逗号隔开多个值，则以最后一个为准

##### 函数名、函数体和函数加载问题

###### 函数的加载问题

JavaScript 加载的时候，只加载函数名，不加载函数体。所以如果想使用内部的成员变量，需要调用函数

###### `函数名()` 与 `函数名` 的区别

```javascript
function fun1(){
	alert(1);
}

console.log(fun1);
// 等效于
console.log(function fun1(){alert(1);});
```

- `函数名()` 调用函数。调用之后，还获取里函数的返回值
- `函数名` 函数对象。相当于直接获取整个函数对象

##### break、continue、return 的区别

- `break` 结束**当前**循环
- `continue` 结束**本次**循环
- `return` 退出当前函数（如果写在循环中，则包含了结束当前循环）

##### 类数组 arguments

在调用函数时，浏览器每次都会传递两个隐含的参数

1. 函数的上下文对象：`this`
2. 封装实参的对象：`arguments`

- `arguments` 是一个类数组对象，它可以通过索引来操作数据，也可以获取长度

- `arguments` 代表的是实参。在调用函数时，所有的实参都会在 `arguments` 中保存
- `arguments` 只在函数中使用，它是当前函数的一个内置对象
- 即使不定义形参，也能使用实参：`arguments[0]` 代表第一个实参
- `arguments` 可以修改实参的值，但不能修改实参的个数。因为 `arguments` 是伪数组

##### 获取函数实参个数

- `函数名.length`
- `arguments.length`

##### 获取当前正在执行的函数对象

- `arguments.callee`

##### 高阶函数

当 *函数A* 接收 *函数B* 作为参数时，或者 *函数A* 把 *函数C* 作为返回值时，这时我们则称 *函数A* 为高阶函数

- 把其它函数作为参数

  ```javascript
  function fun1(a, callback) {
    console.log(a);
    callback();   // callback 是一个函数，所以可以调用
  }
  
  fun1("我是原函数", function () {
  	console.log("我是参数函数");
  });
  ```

- 把其它函数作为返回值

  ```javascript
  function fun3(b) {
    console.log(b);
    return function fun4() {
    	console.log("我是返回值");
    }
  }
  
  var mFun3 = fun3(10);
  mFun3();   // mFun3 是一个函数，所以可以调用
  ```

##### 构造函数

构造函数是一种特殊的函数，主要用来创建和初始化对象，也就是为对象的成员变量赋初始值。它与 `new` 一起使用才有意义

###### 构造函数和普通函数的区别

- 构造函数的创建方式和普通函数没有区别，不同的是构造函数习惯上**首字母大写**
- 构造函数和普通函数的区别就是**调用方式**的不同：普通函数是直接调用，而构造函数需要使用 new 关键字来调用
- **this 的指向不同**
  - 以函数的形式调用时，this 永远都是指向的 window
  - 以方法的形式调用时，this 指向的是调用方法的那个对象
  - 以构造函数的形式调用，this 指向的是心创建的实例对象

###### new 一个构造函数后的执行流程

1. 开辟内存空间，在内存中创建一个新的空对象
2. 让 this 指向这个新的对象
3. 执行构造函数里面的代码，给这个新对象添加属性和方法
4. 返回这个新对象（所以构造函数里面不需要 return）

###### 静态成员和实例成员

在构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添加。通过这两种方式添加的成员，分别是静态成员和实例成员

- 静态成员：在构造函数本身上添加的成员。只能由构造函数本身访问
- 实例成员：在构造函数内部创建的对象成员。只能由实例和的对象来访问

###### 类和实例

使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个**类**。

通过一个构造函数创建的对象，称为该类的**实例**

##### 闭包

如果一个函数的作用域里的局部变量，能被另外一个函数访问，那么这种现象为闭包

###### 闭包的特性

- 函数嵌套函数
- 函数内部可以引用函数外部的参数和变量
- 参数和变量不会被垃圾回收机制回收

###### 产生闭包的条件

- 嵌套函数
- 内部函数引用了外部函数的数据（变量、函数）

###### 作用

- 全局作用域访问局部作用域的变量
- 在内存中缓存一个变量

参考：https://www.cnblogs.com/itjeff/p/10106855.html

#### 作用域

##### 概念

作用域是一个变量或函数的作用范围。作用域在函数定义时，就确定了

##### 目的

为了提高程序的可靠性，同时减少命名冲突

##### 作用域的分类（ES6）

- 全局作用域

  作用于整个 `<script>` 标签内部，或者作用于一个独立的 JS 文件

  - 全局作用域在页面打开时创建，在页面关闭时销毁
  - 在全局作用域中有一个全局对象 window，它代表的是一个浏览器的窗口，由浏览器创建，我们可以直接使用
  - 在全局作用域中创建的变量，都会作为 window 对象的属性保存
  - 在全局作用域中创建的函数，都会作为 window 的方法保存

- 函数作用域

  作用于函数内的代码环境

##### 变量的作用域

- 全局变量

  在全局作用域下声明的变量，叫 *全局变量* 。在全局作用域的任何地方，都可以访问这个变量

  只有浏览器关闭时，才会被销毁，比较占内存

  全局变量属于 `window` 的属性，访问全局变量：`window.变量名`

- 局部变量

  定义在函数内部的变量，叫 *局部变量* ，只能该函数内访问

  函数的形参，也属于局部变量

  当其所在的代码块运行结束后，就会被销毁，比较节约内存空间

##### 作用域的上下级关系

- 在内部作用域中，可以访问外部作用域的变量
- 外部作用域无法访问内部作用域的变量
- 当在函数作用域中操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用（就近原则），如果没有，就向上一级作用域中寻找，直到找到全局作用域，如果全局作用域中依然没有，就报错：ReferenceError

##### 变量的声明提前（变量提升）

- 使用 `var` 声明的变量，会在所有代码执行之前被声明，但不会被赋值如果不使用 `var` 声明全局变量，则不会提前

- 在赋值之前使用被提前声明的变量，变量值为：`undefined`

- 无论哪个作用域的任何变量，如果未经声明就赋值，那么这个变量是属于 `window` 的属性，而且不会做变量的提升

##### 函数的声明提前

- 使用 `function 函数名(){}` 定义的函数，会被提前声明。即整个函数会在所有代码执行之前就被创建完成。所以，我们可以先调用函数，再定义函数
- 使用 `var 变量名 = function(){}` 定义的函数，不会被提前声明

##### 函数的作用域

- 在函数中，使用 `var` 声明的变量，会在函数中所有代码执行之前被声明
- 在函数中，没有 `var` 声明的变量，都是全局变量，并且不会被提前声明
- 定义的形参，就相当于在函数作用域中声明了变量

##### JavaScript 中没有块级作用域（ES6之前）

使用 `{}` 扩起来的区域，即块级作用域

在 if 语句里定义的变量，在 if 语句外也可以使用

```
if (true) {
	var num = 12331;
	console.log("num:" + num);
}
console.log("num:" + num);
```

##### 作用域链

###### 引入

- 只要是代码，就至少有一个作用域
- 写在函数内部的局部作用域
- 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域

###### 定义

内部函数访问外部函数的变量，采用的是链式查找的方式来决定取哪个值，这种结构称之为作用域链。查找时，采用的是**就近原则**

#### 预编译

##### JavaScript 运行三部曲

1. 语法分析
2. 预编译
3. 解释执行

##### 函数预编译的步骤

1. 创建 AO 对象。AO 即 Activation Object 活跃对象，其实就是*执行期上下文*
2. 找形参和变量声明，将形参名和变量名作为 AO 的属性名，值为 undefined
3. 将实参和形参统一，实参的值赋给形参
4. 查找函数声明，将函数名作为 AO 对象的属性名，值为整个函数体

#### this

解析器每次在调用函数时，都会向函数内部传递进一个隐含的参数，这个参数就是 this ，this 指向的是一个对象，这个对象我们称为函数执行的上下文对象

当函数在预编译前一刻，会创建一个执行期上下文的内部对象。一个执行期上下文定义了一个函数执行的环境

每调用一次函数，就会创建一个新的上下文对象，它们之间是相互独立且独一无二的。当函数执行完毕后，它产生的执行期上下文就会被销毁

##### 根据函数的调用方式不同，this 指向的对象也不同

- 通过 `函数名();` 形式调用函数时（包括普通函数、定时器函数、立即执行函数），this 指向的是 window
- 通过对象的形式调用函数时，this 指向的是调用方法的那个对象
- 通过构造函数的形式调用函数时，this 指向的是实例对象
- 通过绑定事件函数形式调用时，this 指向的是绑定事件的对象
- 使用 `call` 或 `apply` 调用函数时，this 指向的是指定的那个对象

##### 箭头函数中 this 的指向

ES6 中的箭头函数，this 不会使用上面的规则，而是继承外层函数的 this

##### 改变函数内部的 this 指向

- `call()`   会调用函数

  ```
  函数名.call(想要指向的this, [实参1, 实参2, ...]);
  ```

  应用：让一个方法继承另外一个方法的属性

  ```javascript
  function father (a, b){
    this.e = a;
    this.f = b;
  }
  function son(c, d){
  	father.call(this, c, d);
  }
  const mSon = new son("李四", 20);
  console.log(mSon);   // 打印：son {e: "李四", f: 20}
  ```

  1. 执行 `new son()` 的时候，`son()` 方法里是没有 e、f 这两个属性的

  2. 然后执行 `father.call()` 的时候，将 `son()` 的 this 传给 `father()` ，然后 `father()` 里的 this 就是 `son()` 的 this，所以 `son()` 有了 `father()` 的属性 e、f

- `apply()`   会调用函数。实参必须时数组的形式传入

  ```
  函数名.apply(想要指向的this, [[实参1, 实参2, ...]]);
  ```

  应用：求数组的最大值

  ```javascript
  const arr1 = [3, 7, 10, 8];
  var maxValue = Math.max.apply(Math, arr1);
  console.log(maxValue);
  ```

- `bind()`   不会调用函数

  ```
  新函数 = 函数名.bind(想要指向的this, [实参1, 实参2, ...]);
  ```

  - 如果不需要改变 this 的指向，则第一个参数传：null
  - 返回值是原函数的拷贝函数

#### 正则表达式

正则表达式（regular expression）描述了一种字符串匹配的模式（pattern），可以用来检查一个字符串是否含有某种子串、将匹配的子串替换或者取出

##### 创建正则表达式的对象

- 使用构造函数

  ```
  var 变量名 = new RegExp("正则表达式", ["匹配模式"]);
  ```

  - 匹配模式

    - `i`   忽略大小写

    - `g`   全局匹配模式

      当设置全局标志 `/g` 时，一旦字符串中还存在匹配，test() 方法都将返回 true，同时匹配成功后将把 `lastIndex` 属性的值**设置为上次匹配成功结果之后的第一个字符所在的位置**，下次匹配将从 `lastIndex` 指示的位置开始；匹配不成功时返回 false，同时将 lastIndex 属性的值重置为 0

      ```javascript
      const reg = /test/g;
      const str = '_test_test';
      
      console.log(reg.test(str)); // true
      console.log(reg.lastIndex); // 5
      
      console.log(reg.test(str)); // true
      console.log(reg.lastIndex); // 10
      
      console.log(reg.test(str)); // false
      console.log(reg.lastIndex); // 0
      ```

      全局匹配模式 `g` 一般用于 `exec()`、`match()`、`replace()`等方法

- 使用字面量

  ```
  var 变量名 = /正则表达式/[匹配模式];
  ```

##### 正则表达式的语法

###### 或：[]

- `/[ab]/` 等价于 `/a|b/`：检查一个字符串中是否包含 a 或 b
- `/[a-z]/`：检查一个字符串那种是否包含任意小写字母
- `/[A-Z]/`：任意大写字母
- `/[A-z]/`：任意字母
- `/[0-9]/`：任意数字
- `/a[bde]c/`：检查一个字符串中是否包含 abc 或 adc 或 aec

###### 除了：[^]

- `/[^ab]/`   字符串中，除了a、b之外，还有没有其他的字符内容？
- `/[^0-9]/`   字符串中，除了数字之外，还有没有其他的内容？

##### 常用正则表达式

- 判断一个字符串是否是一个合法的手机号

  ```
  var phoneReg = /^1[3-9][0-9]{9}$/;
  ```

- 去掉字符串开头和结尾的空格

  ```
  var delSpa = str.replace(/^\s*|\s*$/g,"");
  ```

- 判断字符串是否为电子邮件

  ```
  var emailReg = /^\w{3,}(\.\w+)*@[A-z0-9]+(\.[A-z]{2,5}){1,2}$/;
  ```

#### 事件

##### 事件简介

事件 就是文档或浏览器窗口中发生的一些特定的交互瞬间。如：点击某个元素、将鼠标移动至某个元素上方、关闭弹窗等

JavaScript 与 HTML 之间的交互是通过事件实现的

##### 事件的三要素

- 事件源

  引发后续事件的 HTML 标签

- 事件

  JavaScript 定义好的

  ![常见的事件](https://camo.githubusercontent.com/8b9f269ab37f67948c8e00bceb556f4a270f1223/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303132365f313535332e706e67)

- 事件驱动程序

  对样式和 html 的操作，也就是 DOM

比如，网页上弹出一个广告，我点击右上角的 `X` ，广告就关闭了。这件事情里，事件源是：`X` ，事件是：onclick ，事件驱动程序是：广告关闭了

##### 获取事件源

- 通过 `id` 获取单个标签

  ```
  var 变量名 = document.getElementById("标签的id");
  ```

- 通过 标签名 获取标签数组

  ```
  var 变量名 = document.getElementsByTagName("标签名");
  ```

- 通过 类名 获取标签数组

  ```
  var 变量名 = doucument.getElementsByClassName("标签的class");
  ```

##### 绑定事件的方式

- 直接绑定匿名函数

  ```
  事件源.onclick = function() {
  
  }
  ```

- 先单独定义函数，再绑定

  ```
  事件源.onclick = 函数名;
  
  function 函数名() {
  
  }
  ```

- 行内绑定

  ```html
  <body>
    <div id="btn1" onclick="fn1()"></div>
    
    <srcipt type="text/javascript">
    	function fn1(){
      
      }
    </srcipt>
  </body>
  ```

##### 绑定事件的写法

###### MOM0 的写法

一个元素的一个事件只能绑定一个响应函数。如果绑定了多个响应函数，则后者会覆盖前者

```
element.onclick = function() {

}
```

###### DOM2 的写法（IE9+）

一个元素的一个事件，可以绑定多个回调函数，并且不会被覆盖

执行顺序：按函数的绑定顺序执行

addEventListener() 中的 this ，指向的是：绑定事件的对象

```
element.addEventListener("click", function() {

}, [false]);
```

- 参数1：事件名的字符串（没有 on）
- 参数2：回调函数（当事件触发时，该函数会被执行）
- 参数3：true 表示捕获阶段触发，false 表示冒泡阶段触发（默认）

###### DOM2 的写法（IE8-）

一个元素的一个事件，可以绑定多个响应函数。绑定的响应函数不存在覆盖情况

执行顺序：后绑定的先执行

attachEvent() 中的 this ，指向的是：window

```
element.attachEvent("onclick", function(){

});
```

- 参数1：事件名的字符串（有 on）
- 参数2：回调函数

###### 兼容写法

```javascript
/**
* 为指定的元素绑定指定的响应事件
* 统一了 this
*/
function myBind(element, eventStr, callback){
  if(element.addEventListener){
    // 大部分浏览器的兼容方式
    element.addEventListener(eventStr, callback, false);
  } else {
    // IE8及其以下版本的兼容
    element.attachEvent("on" + eventStr, function(){
      // 在匿名函数 function() 中回调 响应函数
      // call() 改变 this 的指向
      callback.call(element);
    });
  }
}
```

##### 事件驱动程序

- `onload` 事件

  js 的加载是和 html 同步加载的，当页面加载完毕的时候，触发 `onload` 事件

  浏览器在加载一个页面时，是按照自上向下的顺序加载的，读取到一行就运行一行。如果将script标签写到页面的上边，在代码执行时，页面还没有加载，页面没有加载DOM对象也没有加载，会导致无法获取到DOM对象

  ```html
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8" />
      <title></title>
      <script type="text/javascript">
        // 【方式一：先加载，后执行】这段 js 代码是写在 <head> 标签里的，所以建议放在 window.onload 里面。
        window.onload = function() {
          // 获取id为btn的按钮
          var btn = document.getElementById("btn");
          // 为按钮绑定点击事件
          btn.onclick = function() {
            alert("hello");
          };
        };
      </script>
    </head>
    <body>
      <button id="btn">点我一下</button>
  
      <script type="text/javascript">
        // 【方式二：后加载，后执行】这段 js 代码是写在 <body> 标签里的，代码的位置是处在页面的下方。这么做，也可以确保：在页面加载完毕后，再执行 js 代码。
  
        // 获取id为btn的按钮
        var btn = document.getElementById("btn");
        // 为按钮绑定点击事件
        btn.onclick = function() {
          alert("hello");
        };
      </script>
    </body>
  </html>
  ```

##### 事件传播的三个阶段

- 事件捕获

  在 DOM 树结构中，事件从祖先元素忘子元素查找，直到捕获到事件目标 target 。在这个过程中，默认情况下，事件对应的响应函数捕获被触发

- 事件目标

  当到达目标元素后，执行目标元素绑定的响应函数

- 事件冒泡

  事件从目标元素 target 开始，从子元素往祖先元素冒泡，直到页面的最上一级标签

![](https://camo.githubusercontent.com/945ca040a47378c67f526d88afbee16c4e5afe99/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303230345f313231382e6a7067)

##### 事件捕获

`addEventListener()` 第三个参数为 true ，表示事件在捕获阶段执行

捕获阶段，事件的传递顺序：window --> document --> html --> body --> 祖先元素 --> 目标元素

##### 事件冒泡

当一个元素上的事件被触发的时候，同样的事件将会在那个元素所有的祖先元素中触发。这一过程称为事件冒泡

###### 冒泡的顺序

- 一般浏览器（除 IE6 之外）

  目标元素 --> 祖先元素 --> body --> html --> document --> window

- IE6

  目标元素 --> 祖先元素 --> body --> html --> document

###### 不冒泡的事件

blur、focus、load、unload、onmouseenter、onmouseleave

###### 检查一个事件是否会冒泡

```
布尔值 = 事件.bubbles;
```

返回 true ，表示该事件会冒泡

###### 阻止冒泡

- W3C 提供（谷歌、火狐、IE11+）

  ```
  事件.stopPropagation();
  ```

- IE10-

  ```
  事件.cancelBubble = true;
  ```

兼容写法：

```
元素.onclick = function(event){
	event = event || window.event;
	if(event && event.stopPropagation){
		event.stopPropagation();
	} else {
		event.cancelBubble = true;
	}
}
```

##### 事件委托

把一个元素的响应事件的响应函数，委托到另一个元素

事件委托，是利用了事件的冒泡机制，减少了事件绑定的次数，减少内存消耗，提高性能

```html
<body>
    <ul id="linkList">
        <p>段落</p>
        <li><a href="javascript:;" class="link">超链接一</a></li>
        <li><a href="javascript:;" class="link">超链接二</a></li>
        <li><a href="javascript:;" class="link">超链接三</a></li>
        <li><a href="javascript:;" class="link">超链接四</a></li>
        <li><a href="javascript:;" class="link">超链接五</a></li>
    </ul>

    <script>
        document.getElementById("linkList").addEventListener("click", function (event) {
            event = event || window.event;

            console.log(event);

            console.log(event.target);

            console.log(event.target.nodeName);

            // event.target 触发事件的对象
            // if (event.target && event.target.className == "link") {
            //     console.log("超链接被点击了");
            // }
            // 或者
            if (event.target && event.target.nodeName.toUpperCase() == "A") {
                console.log("超链接被点击了");
            }
        }, false);
    </script>
</body>
```
局限性

- 事件本身没有冒泡机制的，无法委托（如：focus、blur）
- 有冒泡机制，但是只能不断的通过位置去计算定位的，对性能消耗高（如：mousemove、mouseout）

参考：https://zhuanlan.zhihu.com/p/26536815

##### 鼠标的拖拽事件

###### 拖拽流程

1. `onmousedown`   当鼠标在被拖拽元素上按下时，开始拖拽
2. `onmousemove`   当鼠标移动时被拖拽元素跟随鼠标移动
3. `onmouseup`   当鼠标松开时，被拖拽元素固定在当前位置

##### 鼠标的滚轮事件

- `onmousewheel`   鼠标滚动滚动的事件，会在滚轮滚动时触发。火狐不支持该属性
- `DOMMouseScroll`   在火狐中需要使用 addEventListener() 来绑定滚轮滚动的事件

##### 键盘事件

- `onkeydown`   按键被按下
  - 如果一直按着某一按键不松开，`onkeydown` 会一直触发。此时松开按键，`onkeyup` 会被执行一次
  - 当 `onkeydown` 连续触发时，第一次和第二次之间会间隔稍微长一点，后续的间隔会非常快。这种设计是为了防止误操作的发生
- `onkeyup`   按键被松开

###### 键盘事件中的 event

- `keyCode`   获取按键的编码
- `altKey`   Alt 键是否被按下
- `ctrlKey`   Ctrl 键是否被按下
- `shiftKey`   Shift 键是否被按下

#### DOM

##### 节点（Node）

构成 HTML 网页的最基本单元。网页中的每一个部分都可以称为一个节点，比如：html 标签、属性、文本、注释、整个文档等

###### 常见节点的分类

- 文档节点 ( 文档 ) ：整个 HTML 文档
- 元素节点 ( 标签 ) ：HTML 标签
- 属性节点 ( 属性 ) ：元素的属性
- 文本节点 ( 文本 ) ：HTML 标签中的文本内容（包括标签之间的空格、换行）

节点的类型不同，属性和方法也都不尽相同。所有的节点都是 Object

##### 什么是 DOM

DOM ( Document Object Model) ，文档对象模型。为文档提供了结构化的表示，并定义如何通过脚步来访问文档结构。目的其实就是为了能让 js 操作 html 元素而制定的一个规范

DOM 就是由节点组成的

###### 解析过程

HTML 加载完后，渲染引擎会在内存中把 HTML 文档，生成一个 DOM 树，`getElementById()` 获取的就是 DOM 上的元素节点。然后操作的时候，修改的是该元素的属性

##### DOM 的作用

- 找对象（元素节点）
- 设置元素的属性值
- 设置元素的样式
- 动态创建和删除元素
- 事件的触发、响应：事件源、事件、事件的驱动程序

##### DOM 中获取有关系的节点

这里，节点都是通过属性来获取

- 获取父节点

  ```
  父节点 = 节点.parentNode
  ```

- 获取下一个兄弟元素节点（标签）

  - `nextBibling`
    - 谷歌、火狐、IE9+ ：获取的是下一个节点（包括标签、文本、空文档、换行节点）
    - IE6、IE7、IE8 ：获取的是下一个元素节点（标签）
  - `nextElementSibling`
    - 谷歌、火狐、IE9+ ： 获取的是下一个元素节点（标签）

  所以，为了兼容的获取下一个元素节点，可以这样写：

  ```
  下一个兄弟节点 = 节点.nextElementSibling || 节点.nextSibling
  ```

- 获取前一个兄弟元素节点（标签）

  - `previousSibling`
    - 谷歌、火狐、IE9+ ： 获取的是前一个节点（包括标签、文本、空文档、换行节点）
    - IE6、IE7、IE8 ： 获取的是前一个元素节点（标签）
  - `perviousElementSibling`
    - 谷歌、火狐、IE9+ ： 获取的是前一个元素节点（标签）

  所以，为了兼容的获取下一个元素节点，可以这样写：

  ```
  前一个兄弟节点 = 节点.previousElementSibling || 节点.previousSibling
  ```

- 获取任意一个兄弟节点

  ```
  兄弟节点 = 节点.parentNode.children[index];
  ```

- 获取第一个子元素节点

  - `firstChild`
    - 谷歌、火狐、IE9+ ： 获取第一个子节点（包括标签、文本、空文档、换行节点）
    - IE6、IE7、IE8 ： 获取第一个子元素节点（标签）
  - `firstElementChild`
    - 谷歌、火狐、IE9+ ： 获取第一个子元素节点（标签）

- 获取最后一个子元素节点

  - `lastChild`
    - 谷歌、火狐、IE9+ ： 获取最后一个子节点（包括标签、文本、空文档、换行节点）
    - IE6、IE7、IE8 ： 获取最后一个子元素节点（标签）
  - `lastElementChild`
    - 谷歌、火狐、IE9+ ： 获取最后一个子元素节点（标签）

- 获取所有的子节点

  - `childNodes`   标准属性。返回的是指定元素的子节点的集合（包括元素节点、所有属性、文本节点）

    - 谷歌、火狐 等高版，会把 换行 也看作是子节点

    ```
    子节点数组 = 节点.childNodes;
    ```

  - `children`   非标准属性。返回的是指定元素的子元素节点的集合（标签）

    - 只返回 HTML 节点，甚至不返回文本节点
    - 在 IE6、IE7、IE8 中，会返回注释节点

    ```
    子元素节点数组 = 节点.children;
    ```

##### DOM 节点的操作

这里，节点的操作都是通过函数

- 创建节点

  ```
  新节点名 = document.createElement("标签名");
  ```

- 插入节点

  - 在节点最后插入一个新节点

    ```
    节点.appendChild(新节点名);
    ```

    **注意：**

    ```html
    <div class="box11">
        <div class="box12">生命壹号</div>
    </div>
    
    <div class="box21">
        <div class="box22">永不止步</div>
    </div>
    ```

    如果这种情况调用方法 `box11.appendChild(box22);` ，结果是：**box22 会跑到 box11 中**

  - 在指定节点前面插入一个新节点

    ```
    节点.insertBefore(新节点名, 指定节点名);
    ```

- 删除节点

  - 删除子节点

    ```
    节点.removeChild(子节点名);
    ```

  - 删除指定节点

    ```
    节点.parentNode.removeChild(节点);
    ```

- 复制节点

  ```
  要复制的节点.cloneNode([true | false]);
  ```

  - `true`   复制节点及其所有的子节点
  - `false`   默认。只复制节点，不复制子节点

- 获取节点的属性值

  ```
  // 方式1:直接操作标签
  属性值 = 元素节点.属性名;
  属性值 = 元素节点[属性名];
  
  // 方式2:把标签作为DOM节点
  属性值 = 元素节点.getAttribute("属性名");
  ```

- 设置节点的属性值

  ```
  // 方式1
  元素节点.属性名 = 属性值;
  
  // 方式2
  元素节点.setAttribute("属性名", "属性值");
  ```

  总结：

  节点的原始属性（比如：普通标签的 `className` 属性），在设置属性值和获取属性值时，方式1、方式2可以混用（即：方式1设置属性值，用方式2获取属性值）；非原始属性，不能混用

  - 方式1：绑定的属性，不会出现在标签上
  - 方式2：绑定的属性，会出现在标签上

- 删除节点的属性

  ```
  元素节点.removeAttribute("属性名");
  ```

- 获取节点的指定属性

  ```
  元素节点.getAttributeNode("属性名");
  ```

  结果是：`属性="属性值"`

- 获取节点里面的内容

  - `value`   获取标签 `value` 属性的值
  - `innerHTML`   获取双闭合标签里面的内容（包含标签）
  - `innerText`   只获取双闭合标签里面的内容。老版本火狐使用：`textContent`
  - `innerHTML` 和 `innerText` 在修改标签内容时的区别
    - `innerHTML`   修改标签本身。修改内容后，会使内容里面包含的标签有本身的作用
    - `innerText`   如果修改的内容里面包含标签，则标签只当作文本处理，标签的作用失效

- 判断节点类型

  ```
  节点类型的数值 = 节点.nodeType;
  ```

  - `nodeType == 1`   元素节点（标签）
  - `nodeType == 2`   属性节点
  - `nodeType == 3`   文本节点

- 获取节点名

  ```
  节点名 = 节点.nodeName;
  ```

- 获取节点的值

  ```
  节点的值 = 节点.nodeValue;
  ```

##### style 属性的获取和修改

DOM 中，设置样式的两种形式

- `className`   针对内嵌式的样式
- `style`   针对行内式的样式。不能获取内嵌的样式和外链的样式
  - `style`   式一个对象

###### 通过 js 读取元素的样式

```
// 方式1
样式的属性值 = 元素.style.样式的属性名;

// 方式2
样式的属性值 = 元素.style["样式的属性名"];
```

方式2 可以给属性传递参数

###### 通过 js 设置元素的样式

```
元素.style.样式的属性名 = "样式的属性值";
```

如果其它地方的样式写了 `!important` ，则其它地方的样式优先级更高

###### 在 js 中同时设置元素的多个样式

```
元素.style.cssText = "样式";
```

###### style 的常用属性

- backgroundColor
- backgroundImage
- color
- width
- height
- border
- opacity 设置透明度 （IE8以前是filter: alpha(opacity=xx)）

###### 通过 js 获取元素的所有样式

只读，不能修改，修改样式只能通过 `style`

- W3C 提供

  ```
  样式对象 = window.getComputedStyle("要获取样式的元素", "伪元素");
  ```

- IE 和 Opear

  ```
  样式对象 = 元素.currentStyle;
  ```

获取到元素的所有样式后，可通过 `样式对象.样式属性名` 来获取 样式的属性值。兼容写法

```
function getStyle(ele, attr){
	if (window.getComputedStyle) {
		return window.getComputedStyle(ele, null)[attr];
	}
	return ele.currentStyle[attr];
}
```

#### BOM

##### BOM 的结构图

![](https://camo.githubusercontent.com/e82acbb54f1a12e60c41b7c220dcaa9ea0daa8f9/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303230315f323035322e706e67)

- window 对象是 BOM 的顶层（核心）对象，所有的对象都是通过它延伸出来的，也可以称为 window 的子对象
- DOM 也是 BOM 的一部分

##### 常见的 BOM 对象

- Window ：代表整个浏览器的窗口。同时 window 也是网页中的全局对象
- Navigator ：代表当前浏览器的信息。通过该对象可以识别不同的浏览器
- Location ：代表当前浏览器的地址栏信息。通过 location 可以获取地址栏信息，或者操作浏览器跳转页面
- History ： 代表浏览器的历史记录。通过该对象可以操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效
- Screen ： 代表用户的屏幕信息。通过该对象可以获取用户显示器的相关信息

这些 BOM 对象都是作为 window 对象的属性保存的，可以通过 window 对象来使用，也可以直接使用

##### Window

window 对象是 JavaScript 中的顶级对象

全局变量、自定义函数也是 window 对象的属性和方法

window 对象下的属性和方法在调用时，可以省略 `window`

###### Window 对象的方法

- 弹出系统对话框

  - `alert(content);`   不同浏览器中的外观不一样
  - `confirm(content);`   兼容性不好
  - `prompt(content);`   不推荐使用

- 打开窗口

  ```
  window.open(url, target, param);
  ```

  - url ：要打开的地址

  - target ：新窗口的位置

  - param ：新窗口的一些设置

    各个参数之间用逗号隔开就行，但我们最好是把它们统一放到json里

    - name：新窗口的名称，可以为空
    - features：属性控制字符串，在此控制窗口的各种属性，属性之间以逗号隔开。
    - fullscreen= { yes/no/1/0 } 是否全屏，默认no
    - channelmode= { yes/no/1/0 } 是否显示频道栏，默认no
    - toolbar= { yes/no/1/0 } 是否显示工具条，默认no
    - location= { yes/no/1/0 } 是否显示地址栏，默认no。（有的浏览器不一定支持）
    - directories = { yes/no/1/0 } 是否显示转向按钮，默认no
    - status= { yes/no/1/0 } 是否显示窗口状态条，默认no
    - menubar= { yes/no/1/0 } 是否显示菜单，默认no
    - scrollbars= { yes/no/1/0 } 是否显示滚动条，默认yes
    - resizable= { yes/no/1/0 } 是否窗口可调整大小，默认no
    - width=number 窗口宽度（像素单位）
    - height=number 窗口高度（像素单位）
    - top=number 窗口离屏幕顶部距离（像素单位）
    - left=number 窗口离屏幕左边距离（像素单位）

  - 返回值：新窗口的句柄（标识符）

- 关闭窗口

  ```
  window.close();
  ```

- 新窗口相关

  - `新窗口.moveTo(5,5)`
  - `新窗口.moveBy()`
  - `新窗口.resizeTo()`
  - `window.resizeBy()`

##### Navigator

由于历史原因， Navigator 对象中的大部分属性都已经不能帮助我们识别浏览器了

**一般我们只会使用 `navigator.userAgent` 来获取浏览器的信息**

`userAgent` 返回的是一个字符串，简称 UA ，这个字符串中包含了用来描述浏览器信息的内容

`platform`   获取浏览器支持的系统，Windows/Mac/Linux

```javascript
<body>
    <script>
        var ua = navigator.userAgent

        if (/firefox/i.test(ua)) {
            console.log("火狐");
        } else if (/chrome/i.test(ua)) {
            console.log("谷歌");
        } else if (/msie/i.test(ua)) {
            console.log("IE");
        } else if ("ActiveXObject" in window) {
            console.log("IE11");
        }
    </script>
</body>
```

#####  History

###### History 对象的属性

- `history.length`   获取浏览器历史列表中 url 的数量

  只统计当次的数量，如果浏览器关闭，数量会重置为 1

###### History 对象的方法

- `back()`   回退到上一个页面。作用和浏览器的「回退按钮」一样
- `forward()`   跳转到下一个页面。作用和浏览器的「前进按钮」一样
- `go(number)`   向前/向后跳转 number 个页面
  - number 为正数，向前跳转
  - number 为负数，向后跳转
  - number 为 0 ，刷新当前页面

##### Location

###### Location 对象的属性

- `location.href`   获取/设置当前页面的 url

  如果是设置当前页面的 url ，则页面会自动跳转到该路径，并生成相应的历史记录
  
- `hash`   获取 url 中 # 后面的内容，包含 #

- `host`   主机名，包括端口

- `hostname`   主机名

- `pathname`   url 中的路径部分

- `protocol`   协议

- `search`   查询字符串

###### Location 对象的方法

- `assign(str)`   跳转到指定的 url

- `reload()`   重新加载当前页面，即刷新

- `replace(str)`   使用一个新页面替换当前页面

  调用完毕也会跳转页面，但不会生成历史记录，不能使用「回退按钮」

#### 定时器

##### setInterval()

循环调用。将一段代码，每隔一段时间执行一次

- 参数1 ：回调函数。该函数会每隔一段时间被调用一次
- 参数2 ：每次调用的间隔时间，单位是毫秒
- 返回值 ：返回一个 Number 类型的数据。这个数字用来作为定时器的唯一标识，方便用来清除定时器

##### setTimeout()

延时调用。将一段代码，等一段时间之后再执行

- 参数1 ：回调函数。该函数在指定的时间之后，执行一次
- 参数2 ：延迟调用函数的时间，单位是毫秒
- 返回值 ：返回一个 Number 类型的数据

##### clearInterval()

清除定时器。清除后定时器停止

- 参数1 ：定时器的唯一标识

---

### JavaScript 动画

JavaScript 动画的主要内容：

- 三大家族和一个事件对象
  - 三大家族：offset、scroll、client
  - 事件对象：event
- 动画（闪现、匀速、缓动）
- 冒泡、兼容、封装

#### 三大家族和一个事件

##### offset

- `offsetWidth` 和 `offsetHight`

  获取元素的宽、高

  - offsetWidth = width + padding + border
  - offsetHeight = height + padding + border

- `offsetParent`

  获取元素最近的有 CSS 定位（position为absolute、relative、fixed）的祖先元素，如果祖先元素都没有定位，那么则返回 `<body>`

- `offsetLeft` 和 `offsetTop`

  获取元素相对于其定位的祖先元素的水平、垂直偏移量

  - `offsetLeft` 与 `style.left` 的区别
    - `offsetLeft` 可以返回无定位祖先元素的偏移量，如果祖先元素中都没有定位，则以 `<body>` 为准
    - `style.left` 只能获取行内式的样式，如果祖先元素中都没有定位，则放回 "" ，空字符串
    - `offsetLeft` 返回的是数字，`style.left` 返回的是带 px 的字符串
    - `offsetLeft` 只读，`style.left` 可读写

##### scroll

- 当我们使用鼠标滚轮，滚动网页的时候，会触发 `window.onscroll()`

  - `scrollWidth` 和 `scrollHeight`

    获取滚动区域的宽、高

    - scrollWidth = width + padding
    - scrollHeight = height + padding

    如果内容超出了盒子，获取的宽、高包括**超出部分**

  - `scrollLeft` 和 `scrollTop`

    获取水平、垂直滚动条滚动的距离

    - 判断垂直滚动条滚动到底部

      ```
      scrollHeight - scrollTop == clientHeight
      ```

    - 判断水平滚动条滚动到底部

      ```
      scrollWidth - scrollLeft == clientWidth
      ```

    - 兼容问题

      1. 如果文档没有 DTD 声明，chrome 要求这样写才能识别

         ```
         document.body.scrollTop
         ```

      2. 文档有 DTD 声明，IE6、IE7、IE8 这样写才能识别

         ```
         document.documentElement.scrollTop
         ```

      3. 无视 DTD 声明的写法（兼容：谷歌、火狐、IE9+）

         ```
         window.pageYOffset
         ```

      最终兼容写法：

      ```
      window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop
      ```

      判断是否有 DTD 声明

      ```
      document.compatMode === "CSS1Compat"   // 已声明
      document.compatMode === "BackCompat"   // 未声明
      ```

##### client

- `clientWidth` 和 `clientHeight`

  获取元素的可见宽度、高度（width/height + padding）

  - 该属性是只读，不可修改
  - 返回值是数字，不带 px
  - 不包含滚动条

- `clientX` 和 `clientY`

  鼠标距离可视区域左侧、上侧的距离

- `clientTop` 和 `clientLeft`

  盒子的上侧、左侧的border

###### 封装：获取可视区域的宽、高

```javascript
function client(){
  if(window.innerHeight!=undefined){
    //IE9+
    return{
    "width":window.innerHeight,
    "height":window.innerHeight
    }
  }elseif(document.compatMode==="CSS1Compat"){
    //声明了DTD
    return{
    "width":document.documentElement.clientWidth,
    "height":document.documentElement.clientHeight
    }
  }else{
    //未声明DTD
    return{
    "width":document.body.clientWidth,
    "height":document.body.clientHeight
    }
  }
}
```

##### 三大家族的区别

###### 区别1：宽、高

- offsetWidth = width + padding + border
- offsetHeight = height + padding + border
- scrollWidth = 内容宽度 + padding
- scrollHeight = 内容高度 + padding
- clientWidth = width + padding
- clientHeight = height + padding

###### 区别2：上、左

- `offsetTop` 和 `offsetLeft`
  - 调用者：任意元素
  - 作用：获取元素到 带有定位且离自己最近的祖先元素 的距离
- `scrollTop` 和 `scrollLeft`
  - 调用者：`document.body` 或 `window` 或者 带有滚动条的盒子
  - 作用：显示盒子没有展示的部分
- `clientY` 和  `clientX`
  - 调用者：event
  - 作用：鼠标距离浏览器可视区域的距离

##### 其它方法

- `innerWidth` 和 `innerHeight`

  获取可视区域的宽、高（width/height + padding）

  - 包含滚动条
  - 这个属性是只读，并且没有默认值

- `window.screen.width` 和 `window.screen.height`

  获取显示器的分辨率

- `window.onscroll` 事件

  鼠标滚轮滚动网页时调用

- `window.onresize` 事件

  浏览器改变大小的时候调用

- `window.onload` 事件

  页面加载完毕时调用

- `div.onmousemove` 事件

  鼠标在盒子上移动的时候调用（不是移动盒子）

##### event

当事件的响应函数被触发时，会产生一个事件对象 `event` 。浏览器每次都会将这个事件对象，作为实参传进响应函数

这个对象中包含了与当前事件相关的一切信息。比如鼠标的坐标、键盘的哪个按键被按下、鼠标滚轮滚动的方向等

###### 获取 event 对象

- 普通浏览器的写法：`event`
- IE7、IE7、IE8 的写法：`window.event`

兼容性的写法

```
event = event || window.event;
```

###### event 的属性

![](http://img.smyhvae.com/20180203_1739.png)

由于pageX 和 pageY的兼容性不好，我们可以这样做：

- 鼠标在页面的位置 = 滚动条滚动的距离 + 可视区域的坐标

#### 动画

##### 闪现

```html
<style>
  #box1 {
    width: 100px;
    height: 100px;
    background-color: skyblue;
    position: absolute;
  }
</style>

<body>
    <button id="btnStar" style="margin-bottom: 100px;">开始</button>
    <div id="box1"></div>

    <script>
        var btnStar = document.getElementById("btnStar");
        var box1 = document.getElementById("box1");

        btnStar.onclick = function () {
            box1.style.left = "400px";
        }
    </script>
</body>
```

##### 匀速

```html
<style>
  #box1 {
    width: 100px;
    height: 100px;
    background-color: skyblue;
    position: absolute;
  }
</style>

<body>
    <button id="btnStar" style="margin-bottom: 100px;">开始</button>
    <div id="box1"></div>

    <script>
        var btnStar = document.getElementById("btnStar");
        var box1 = document.getElementById("box1");

        btnStar.onclick = function() {
            var si = setInterval(function() {
                box1.style.left = box1.offsetLeft + 10 + "px";
              	// 移动到 500px 的时候，停止
                if(box1.offsetLeft >= 500){
                    clearInterval(si);
                }
            }, 20);
        }
    </script>
</body>
```

封装：每间隔30ms，将盒子向右移动10px

```javascript
    function animate(ele, target) {
        //要用定时器，先清除定时器
        //一个盒子只能有一个定时器，这样的话，不会和其他盒子出现定时器冲突
        //我们可以把定时器本身，当成为盒子的一个属性
        clearInterval(ele.timer);
        //我们要求盒子既能向前又能向后，那么我们的步长就得有正有负
        //目标值如果大于当前值取正，目标值如果小于当前值取负
        var speed = target > ele.offsetLeft ? 10 : -10;  //speed指的是步长
        ele.timer = setInterval(function () {
            //在执行之前就获取当前值和目标值之差
            var val = target - ele.offsetLeft;

            //移动的过程中，如果目标值和当前值之差如果小于步长，那么就不能在前进了
            //因为步长有正有负，所有转换成绝对值来比较
            if (Math.abs(val) < Math.abs(speed)) {  //如果val小于步长，则直接到达目的地；否则，每次移动一个步长
                ele.style.left = target + "px";
                clearInterval(ele.timer);
            } else {
                ele.style.left = ele.offsetLeft + speed + "px";
            }
        }, 30)
    }
```

##### 缓动

- `Math.ceil()`   向上取整
- `Math.floor()`   向下取整
- `Math.round()`   四舍五入

缓动动画的原理：在移动过程中，步长越来越小

```
移动后盒子的最终位子 = 盒子当前位置 + (目标位置 - 盒子当前位置) / 10;
```

###### 缓动动画的封装

```javascript
function animate(ele,target){
  clearInterval(ele.timer);
  ele.timer=setInterval(()=>{
    vareleLeft=ele.offsetLeft;
    vareleStep=(target-eleLeft)/10;
    eleStep=eleStep>0?Math.ceil(eleStep):Math.floor(eleStep);
    ele.style.left=eleLeft+eleStep+"px";

    //如果当前位置与要移动到的位置距离小于步长，则直接移动到最终位置
    if(Math.abs(target-ele.offsetLeft)<Math.abs(eleStep)){
      ele.style.left=target+"px";
      clearInterval(ele.timer);
    }
  },30);
}
```

#### Html 文档相关信息的获取

- `document.title`   获取文档标题
- `document.head`   获取文档的 `<head>` 标签
- `document.body`   获取文档的 `<body>` 标签
- `document.documentElement`   获取文档的 `<html>` 标签

`document` 是作为 `window` 的属性保存的

---

### 原型

##### 原型的概念

我们所创建的每一个函数，解析器都会向函数中添加一个属性 `prototype` 。这个属性对应着一个对象，这个对象就是我们所谓的原型对象

如果函数作为普通函数调用 `prototype` 没有任何作用，当函数以构造函数的形式调用时，它所创建的实例对象中，都会有一个隐含的属性，指向该构造函数的原型，我们可以通过 `_proto_` 来访问该属性

原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中

所以，我们在创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样就不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了

使用 `in` 检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回 true

可以使用对象的 `hasOwnProperty()` 来检查对象自身中是否含有该属性

##### 原型规则

- 规则1

  所有的引用类型（数组、对象、函数），都具有对象特征，都可以自由扩展属性。null 除外

- 规则2

  所有的引用类型（数组、对象、函数），都有一个 `_proto_` 属性，属性值是一个普通的对象。`_proto_` 的含义是隐式原型

- 规则3

  所有的函数，都有一个 `prototype` 属性，属性值是一个普通的对象。`prototype` 的含义是显式原型

- 规则4

  所有的引用类型（数组、对象、函数），`_proto_` 属性指向它的构造函数的 `prototype` 值

- 规则5

  当试图获取一个对象的某个属性时，如果这个对象没有这个属性，那么会去它的 `_proto_` 中寻找（即它的构造函数的 `prototype`）

##### 原型链

原型对象也是对象，所以它也有原型，当我们使用或访问一个对象的属性和方法时，步骤是：

1. 它会先在对象自身中寻找，如果有则直接使用
2. 如果没有，则会去原型对象中寻找，如果找到则直接使用
3. 如果没有，则去原型的原型中寻找，直到找到 Object 对象的原型
4. Object 对象的原型没有原型，如果 Object 原型中依然没有，则返回 null

---

### JavaScript 的垃圾回收机制

程序运行过程中会产生垃圾，这些垃圾积攒过多以后，会导致程序运行速度减慢。所以我们需要一个垃圾回收机制，来处理程序运行过程中产生的垃圾

当一个对象没有任何变量或属性对它进行引用时，我们将永远无法操作该对象，此时这个对象就是一个垃圾。如果这种对象过多，会占用大量的内存空间，导致运行变慢，所以这种垃圾必须进行清理

上面这句话，也可以理解为：如果堆内存中的对象，在栈内存中没有任何变量指向它，则这个对象就是垃圾

JavaScript 拥有自动的垃圾回收机制，会自动将这些对象从内存中销毁。我们不需要也不能进行垃圾回收操作。我们仅需要做的是：如果你不再使用该对象，那么，将对象的引用设置为 `null` 即可

---

### 内存溢出和内存泄露

#### 内存溢出

内存溢出，是一种程序运行出现的错误。当程序运行需要的内存，超过了剩余的内存时，就会跑出内存溢出的错误

#### 内存泄露

占用的内存没有及时释放

内存泄露的次数积累多了，就容易导致内存溢出

##### 常见的内存泄露

- 意外的全局变量
- 没有及时清理的计数器或回调函数
- 闭包